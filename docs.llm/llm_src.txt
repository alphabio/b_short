Excluding patterns:
Documentation for LLMs
Excluding patterns:
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/animation-layers.ts ===
// b_path:: src/animation-layers.ts

import * as csstree from "css-tree";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import type { AnimationLayer, AnimationResult } from "./schema";

// CSS default values for animation properties
export const ANIMATION_DEFAULTS = {
  name: "none",
  duration: "0s",
  timingFunction: "ease",
  delay: "0s",
  iterationCount: "1",
  direction: "normal",
  fillMode: "none",
  playState: "running",
} as const;

/**
 * Detects if an animation value needs advanced parsing (multi-layer animations or complex functions)
 */
export function needsAdvancedParser(value: string): boolean {
  // Use advanced parsing for:
  // 1. Multi-layer animations (comma-separated)
  // 2. Complex timing functions with parentheses
  // Must ignore commas inside parentheses/brackets (functions, rgba(), etc.)
  let parenDepth = 0;
  let bracketDepth = 0;
  let hasFunctions = false;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
      hasFunctions = true;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this indicates multiple layers
      return true;
    }
  }

  // Use advanced parsing for complex timing functions
  return hasFunctions;
}

/**
 * Splits an animation value into layers, respecting nested functions
 */
function splitLayers(value: string): string[] {
  const layers: string[] = [];
  let currentLayer = "";
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this separates layers
      layers.push(currentLayer.trim());
      currentLayer = "";
      continue;
    }

    currentLayer += char;
  }

  // Add the last layer
  if (currentLayer.trim()) {
    layers.push(currentLayer.trim());
  }

  return layers;
}

/**
 * Parses a complex animation value using css-tree AST parsing
 */
export function parseAnimationLayers(value: string): AnimationResult | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer to extract all properties
    const layers: AnimationLayer[] = [];

    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);
      if (!parsedLayer) {
        return undefined; // Parsing failed for this layer
      }
      layers.push(parsedLayer);
    }

    return {
      layers,
    };
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Parses a single animation layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): AnimationLayer | undefined {
  const result: AnimationLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling animation property parsing
  if (!processCssChildren(children, result)) {
    return undefined; // Parsing failed due to invalid syntax
  }

  return result;
}

/**
 * Processes CSS AST children sequentially to extract animation properties
 *
 * This function handles the parsing of CSS animation layer syntax,
 * including animation names, time values, timing functions, iteration counts,
 * direction, fill mode, and play state.
 * CSS ordering rules: first time = duration, second time = delay
 *
 * Returns false if parsing should fail (e.g., too many time values, unrecognized tokens, duplicates)
 */
function processCssChildren(children: csstree.CssNode[], result: AnimationLayer): boolean {
  let timeCount = 0; // Track first vs second time value

  for (const child of children) {
    let matched = false; // Track if this token was recognized

    // Skip whitespace and operators
    if (child.type === "WhiteSpace" || child.type === "Operator") {
      continue;
    }

    // Handle animation name first (can be any identifier including var() or quoted strings)
    if (!result.name) {
      if (child.type === "Identifier") {
        const name = (child as csstree.Identifier).name;
        if (name === "none") {
          result.name = "none";
          matched = true;
        }
        // Check if it looks like a valid animation name identifier
        // Allow custom identifiers matching pattern, but exclude timing functions and other keywords
        else if (
          /^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(name) &&
          !isTimingFunction(name) &&
          !/^(normal|reverse|alternate|alternate-reverse|none|forwards|backwards|both|running|paused|infinite)$/i.test(
            name
          )
        ) {
          result.name = name;
          matched = true;
        }
      } else if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (funcValue.startsWith("var(")) {
          result.name = funcValue;
          matched = true;
        }
      } else if (child.type === "String") {
        result.name = csstree.generate(child);
        matched = true;
      }

      if (matched) continue;
    }

    // Handle time values (duration and delay)
    if (child.type === "Dimension") {
      const timeValue = csstree.generate(child);
      if (isTime(timeValue)) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = timeValue;
        } else {
          result.delay = timeValue;
        }
        timeCount++;
        matched = true;
      }
    }

    // Handle var() functions as time values
    if (child.type === "Function") {
      const funcValue = csstree.generate(child);
      if (funcValue.startsWith("var(")) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = funcValue;
        } else {
          result.delay = funcValue;
        }
        timeCount++;
        matched = true;
      }
    }

    // Handle timing functions (keywords and functions)
    if (!result.timingFunction) {
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          result.timingFunction = timingValue;
          matched = true;
        }
      }

      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          // Fix spacing in function calls (css-tree removes spaces after commas)
          result.timingFunction = funcValue.replace(/,([^\s])/g, ", $1");
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          return false; // Duplicate timing function
        }
      }
      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          return false; // Duplicate timing function
        }
      }
    }

    // Handle iteration count
    if (!result.iterationCount) {
      if (child.type === "Number") {
        const numValue = csstree.generate(child);
        result.iterationCount = numValue;
        matched = true;
      }
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (identValue === "infinite") {
          result.iterationCount = "infinite";
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Number") {
        return false; // Duplicate iteration count
      }
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (identValue === "infinite") {
          return false; // Duplicate iteration count
        }
      }
    }

    // Handle direction keywords
    if (!result.direction) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(normal|reverse|alternate|alternate-reverse)$/i.test(identValue)) {
          result.direction = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(normal|reverse|alternate|alternate-reverse)$/i.test(identValue)) {
          return false; // Duplicate direction
        }
      }
    }

    // Handle fill mode keywords
    if (!result.fillMode) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(none|forwards|backwards|both)$/i.test(identValue)) {
          result.fillMode = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(none|forwards|backwards|both)$/i.test(identValue)) {
          return false; // Duplicate fill mode
        }
      }
    }

    // Handle play state keywords
    if (!result.playState) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(running|paused)$/i.test(identValue)) {
          result.playState = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(running|paused)$/i.test(identValue)) {
          return false; // Duplicate play state
        }
      }
    }

    // If token was not matched by any category, it's unrecognized
    if (!matched) {
      return false;
    }
  }

  return true;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: AnimationLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "animation-name": layers.map((l) => l.name || ANIMATION_DEFAULTS.name),
    "animation-duration": layers.map((l) => l.duration || ANIMATION_DEFAULTS.duration),
    "animation-timing-function": layers.map(
      (l) => l.timingFunction || ANIMATION_DEFAULTS.timingFunction
    ),
    "animation-delay": layers.map((l) => l.delay || ANIMATION_DEFAULTS.delay),
    "animation-iteration-count": layers.map(
      (l) => l.iterationCount || ANIMATION_DEFAULTS.iterationCount
    ),
    "animation-direction": layers.map((l) => l.direction || ANIMATION_DEFAULTS.direction),
    "animation-fill-mode": layers.map((l) => l.fillMode || ANIMATION_DEFAULTS.fillMode),
    "animation-play-state": layers.map((l) => l.playState || ANIMATION_DEFAULTS.playState),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/animation.ts ===
// b_path:: src/animation.ts

import {
  ANIMATION_DEFAULTS,
  needsAdvancedParser,
  parseAnimationLayers,
  reconstructLayers,
} from "./animation-layers";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const ITERATION_COUNT = /^(infinite|[0-9]+(\.[0-9]+)?)$/;
const DIRECTION = /^(normal|reverse|alternate|alternate-reverse)$/i;
const FILL_MODE = /^(none|forwards|backwards|both)$/i;
const PLAY_STATE = /^(running|paused)$/i;

export default function animation(value: string): Record<string, string> | undefined {
  // Handle global keywords first
  if (KEYWORD.test(value.trim())) {
    return {
      "animation-name": value.trim(),
      "animation-duration": value.trim(),
      "animation-timing-function": value.trim(),
      "animation-delay": value.trim(),
      "animation-iteration-count": value.trim(),
      "animation-direction": value.trim(),
      "animation-fill-mode": value.trim(),
      "animation-play-state": value.trim(),
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(value)) {
    const layeredResult = parseAnimationLayers(value);
    if (layeredResult) {
      return reconstructLayers(layeredResult.layers);
    }
    return undefined; // Advanced parsing failed
  }

  // Simple single-layer fallback parser
  const result: Record<string, string> = {};
  const tokens = value.trim().split(/\s+/);
  let timeCount = 0; // Track first vs second time value

  for (const token of tokens) {
    // Handle animation name first (can be any identifier including var() or quoted strings)
    if (!result["animation-name"]) {
      if (token === "none") {
        result["animation-name"] = "none";
        continue;
      }
      // Check if it looks like a valid animation name identifier
      // Allow custom identifiers matching pattern, var() functions, quoted strings, but exclude timing functions and other keywords
      if (
        (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(token) ||
          token.startsWith("var(") ||
          (token.startsWith('"') && token.endsWith('"')) ||
          (token.startsWith("'") && token.endsWith("'"))) &&
        !isTimingFunction(token) &&
        !DIRECTION.test(token) &&
        !FILL_MODE.test(token) &&
        !PLAY_STATE.test(token) &&
        !ITERATION_COUNT.test(token)
      ) {
        result["animation-name"] = token;
        continue;
      }
    }

    // Handle time values (duration and delay) - CSS allows flexible ordering
    if (isTime(token)) {
      if (timeCount === 0) {
        result["animation-duration"] = token;
      } else if (timeCount === 1) {
        result["animation-delay"] = token;
      } else {
        // More than 2 time values is invalid
        return undefined;
      }
      timeCount++;
      continue;
    }

    // Handle timing functions
    if (!result["animation-timing-function"] && isTimingFunction(token)) {
      result["animation-timing-function"] = token;
      continue;
    }

    // Handle iteration count
    if (!result["animation-iteration-count"] && ITERATION_COUNT.test(token)) {
      result["animation-iteration-count"] = token;
      continue;
    }

    // Handle direction keywords
    if (!result["animation-direction"] && DIRECTION.test(token)) {
      result["animation-direction"] = token;
      continue;
    }

    // Handle fill mode keywords
    if (!result["animation-fill-mode"] && FILL_MODE.test(token)) {
      result["animation-fill-mode"] = token;
      continue;
    }

    // Handle play state keywords
    if (!result["animation-play-state"] && PLAY_STATE.test(token)) {
      result["animation-play-state"] = token;
      continue;
    }

    // If token doesn't match any category, it's invalid
    return undefined;
  }

  // Accept single-token property values - they will expand to defaults

  // Build final result with defaults
  return {
    "animation-name": result["animation-name"] || ANIMATION_DEFAULTS.name,
    "animation-duration": result["animation-duration"] || ANIMATION_DEFAULTS.duration,
    "animation-timing-function":
      result["animation-timing-function"] || ANIMATION_DEFAULTS.timingFunction,
    "animation-delay": result["animation-delay"] || ANIMATION_DEFAULTS.delay,
    "animation-iteration-count":
      result["animation-iteration-count"] || ANIMATION_DEFAULTS.iterationCount,
    "animation-direction": result["animation-direction"] || ANIMATION_DEFAULTS.direction,
    "animation-fill-mode": result["animation-fill-mode"] || ANIMATION_DEFAULTS.fillMode,
    "animation-play-state": result["animation-play-state"] || ANIMATION_DEFAULTS.playState,
  };
}


=== File: src/background-layers.ts ===
// b_path:: src/background-layers.ts

import * as csstree from "css-tree";
import isColor from "./is-color";
import type { BackgroundLayer, BackgroundResult } from "./schema";

// CSS default values for background properties
export const BACKGROUND_DEFAULTS = {
  image: "none",
  position: "0% 0%",
  size: "auto auto",
  repeat: "repeat",
  attachment: "scroll",
  origin: "padding-box",
  clip: "border-box",
} as const;

/**
 * Detects if a background value needs advanced parsing (multi-layer backgrounds)
 */
export function needsAdvancedParser(value: string): boolean {
  // Only use advanced parsing for actual multi-layer backgrounds (comma-separated)
  // Must ignore commas inside parentheses/brackets (functions, rgba(), etc.)
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this indicates multiple layers
      return true;
    }
  }

  return false;
}

/**
 * Splits a background value into layers, respecting nested functions
 */
function splitLayers(value: string): string[] {
  const layers: string[] = [];
  let currentLayer = "";
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this separates layers
      layers.push(currentLayer.trim());
      currentLayer = "";
      continue;
    }

    currentLayer += char;
  }

  // Add the last layer
  if (currentLayer.trim()) {
    layers.push(currentLayer.trim());
  }

  return layers;
}

/**
 * Parses a complex background value using css-tree AST parsing
 */
export function parseBackgroundLayers(value: string): BackgroundResult | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer to extract all properties
    const parsedLayers: Array<BackgroundLayer & { color?: string }> = [];
    let globalColor: string | undefined;

    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);

      // Extract color from the last layer that has one
      if (parsedLayer.color) {
        globalColor = parsedLayer.color;
      }

      parsedLayers.push(parsedLayer);
    }

    // Now distribute properties across layers according to CSS rules
    const layers = distributeLayerProperties(parsedLayers);

    return {
      layers,
      color: globalColor,
    };
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Distributes properties across layers according to CSS background rules
 */
function distributeLayerProperties(
  parsedLayers: Array<BackgroundLayer & { color?: string }>
): BackgroundLayer[] {
  // For CSS backgrounds, properties are NOT distributed across layers.
  // Each layer only gets the properties that were explicitly specified for it.
  // Unspecified properties remain undefined and get default values during reconstruction.

  const result: BackgroundLayer[] = [];

  // Just copy the parsed properties - no distribution needed
  for (const layer of parsedLayers) {
    const { color: _, ...layerProps } = layer;
    result.push(layerProps);
  }

  // Special handling for origin/clip: if a layer specifies only one box value,
  // it applies to both origin and clip
  result.forEach((layer) => {
    if (layer.origin !== undefined && layer.clip === undefined) {
      layer.clip = layer.origin;
    }
  });

  return result;
}

/**
 * Parses a single background layer using css-tree AST parsing
 */
function parseSingleLayerWithCssTree(layerValue: string): BackgroundLayer & { color?: string } {
  const result: BackgroundLayer & { color?: string } = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling position/size parsing
  processCssChildren(children, result);

  return result;
}

/**
 * Processes CSS AST children sequentially to extract background properties
 *
 * This function handles the complex parsing of CSS background layer syntax,
 * including position/size combinations separated by "/", various keyword types,
 * and proper ordering according to CSS specifications.
 */
function processCssChildren(
  children: csstree.CssNode[],
  result: BackgroundLayer & { color?: string }
): void {
  let i = 0;
  let hasPositionSize = false;

  while (i < children.length) {
    const child = children[i];

    // Skip whitespace and operators (except "/")
    if (child.type === "WhiteSpace") {
      i++;
      continue;
    }

    if (child.type === "Operator" && (child as csstree.Operator).value !== "/") {
      i++;
      continue;
    }

    // Handle background-image (url(), none, or image functions like gradients)
    if (child.type === "Url" && !result.image) {
      result.image = `url(${(child as csstree.Url).value})`;
      i++;
      continue;
    }

    if (child.type === "Function") {
      const funcNode = child as csstree.FunctionNode;
      if (
        [
          "linear-gradient",
          "radial-gradient",
          "conic-gradient",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeating-conic-gradient",
          "image",
          "element",
        ].includes(funcNode.name)
      ) {
        if (!result.image) {
          result.image = csstree.generate(child);
        }
        i++;
        continue;
      }
    }

    if (
      child.type === "Identifier" &&
      (child as csstree.Identifier).name === "none" &&
      !result.image
    ) {
      result.image = "none";
      i++;
      continue;
    }

    // Handle position and size (complex parsing needed)
    if (
      !hasPositionSize &&
      ((child.type === "Operator" && (child as csstree.Operator).value === "/") ||
        (child.type === "Identifier" &&
          ["left", "center", "right", "top", "bottom"].includes(
            (child as csstree.Identifier).name
          )) ||
        child.type === "Dimension" ||
        child.type === "Percentage" ||
        child.type === "Number")
    ) {
      const positionParts: string[] = [];
      const sizeParts: string[] = [];
      let _hasSlash = false;

      // Check if we start with "/"
      if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
        _hasSlash = true;
        i++; // skip "/"

        // Collect size parts
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }
          if (
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Identifier" &&
              ["auto", "cover", "contain"].includes((currentChild as csstree.Identifier).name))
          ) {
            sizeParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      } else {
        // Collect position parts until we hit "/" or a non-position node
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }

          if (
            currentChild.type === "Operator" &&
            (currentChild as csstree.Operator).value === "/"
          ) {
            _hasSlash = true;
            i++; // skip "/"

            // Collect size parts
            while (i < children.length) {
              const sizeChild = children[i];
              if (sizeChild.type === "WhiteSpace") {
                i++;
                continue;
              }
              if (
                sizeChild.type === "Dimension" ||
                sizeChild.type === "Percentage" ||
                sizeChild.type === "Number" ||
                (sizeChild.type === "Identifier" &&
                  ["auto", "cover", "contain"].includes((sizeChild as csstree.Identifier).name))
              ) {
                sizeParts.push(csstree.generate(sizeChild));
                i++;
              } else {
                break;
              }
            }
            break;
          } else if (
            (currentChild.type === "Identifier" &&
              ["left", "center", "right", "top", "bottom"].includes(
                (currentChild as csstree.Identifier).name
              )) ||
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number"
          ) {
            positionParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      }

      if (positionParts.length > 0) {
        result.position = positionParts.join(" ");
      }
      if (sizeParts.length > 0) {
        result.size = sizeParts.join(" ");
      }

      hasPositionSize = true;
      continue;
    }

    // Handle repeat values
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(name)) {
        if (!result.repeat) {
          let repeat = name;
          i++;

          // Check for second repeat value
          if (i < children.length && children[i].type === "Identifier") {
            const nextName = (children[i] as csstree.Identifier).name;
            if (
              ["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(nextName)
            ) {
              repeat += ` ${nextName}`;
              i++;
            }
          }

          result.repeat = repeat;
        } else {
          i++;
        }
        continue;
      }
    }

    // Handle attachment
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["fixed", "local", "scroll"].includes(name)) {
        if (!result.attachment) {
          result.attachment = name;
        }
        i++;
        continue;
      }
    }

    // Handle box values (origin/clip)
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["border-box", "padding-box", "content-box"].includes(name)) {
        if (!result.origin) {
          result.origin = name;
        } else if (!result.clip) {
          result.clip = name;
        }
        i++;
        continue;
      }
    }

    // Handle colors
    if (child.type === "Identifier" || child.type === "Function") {
      const value = csstree.generate(child);
      if (isColor(value)) {
        result.color = value;
        i++;
        continue;
      }
    }

    // Skip unrecognized nodes
    i++;
  }
}

/**
 * Parses a single background layer using css-tree AST parsing
 *
 * This function now uses css-tree for robust CSS parsing instead of
 * the previous custom tokenizer approach.
 */
function parseSingleLayer(layerValue: string): BackgroundLayer & { color?: string } {
  return parseSingleLayerWithCssTree(layerValue);
}

/**
 * Distributes property values across layers according to CSS rules
 */
export function distributeProperties(
  layers: BackgroundLayer[],
  properties: Record<string, string[]>
): BackgroundLayer[] {
  const result = layers.map((layer) => ({ ...layer }));

  // Apply property distribution for each property type
  Object.entries(properties).forEach(([property, values]) => {
    const distributedValues = distributeValues(values, layers.length);

    distributedValues.forEach((value, index) => {
      if (result[index]) {
        (result[index] as BackgroundLayer)[property as keyof BackgroundLayer] = value;
      }
    });
  });

  return result;
}

/**
 * Distributes values across layers using CSS repetition rules
 */
export function distributeValues(values: string[], layerCount: number): string[] {
  if (values.length === 0) return [];

  const result: string[] = [];

  for (let i = 0; i < layerCount; i++) {
    // CSS rule: repeat values cyclically if fewer than layers
    result.push(values[i % values.length]);
  }

  return result;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(
  layers: BackgroundLayer[],
  color?: string
): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "background-image": layers.map((l) => l.image || BACKGROUND_DEFAULTS.image),
    "background-position": layers.map((l) => l.position || BACKGROUND_DEFAULTS.position),
    "background-size": layers.map((l) => l.size || BACKGROUND_DEFAULTS.size),
    "background-repeat": layers.map((l) => l.repeat || BACKGROUND_DEFAULTS.repeat),
    "background-attachment": layers.map((l) => l.attachment || BACKGROUND_DEFAULTS.attachment),
    "background-origin": layers.map((l) => l.origin || BACKGROUND_DEFAULTS.origin),
    "background-clip": layers.map((l) => l.clip || BACKGROUND_DEFAULTS.clip),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  // Add color if specified
  if (color) {
    result["background-color"] = color;
  }

  return result;
}


=== File: src/background.ts ===
// b_path:: src/background.ts

import { needsAdvancedParser, parseBackgroundLayers, reconstructLayers } from "./background-layers";
import { cssUrlRegex } from "./color-utils";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const ATTACHMENT = /^(fixed|local|scroll)$/;
const BOX = /^(border-box|padding-box|content-box)$/;
const IMAGE = new RegExp(`^(none|${cssUrlRegex().source})$`, "i");
const REPEAT_SINGLE = /^(repeat-x|repeat-y)$/i;
const REPEAT_DOUBLE = /^(repeat|space|round|no-repeat)$/i;
const POSITION_HORIZONTAL = /^(left|center|right)$/;
const POSITION_VERTICAL = /^(top|center|bottom)$/;
const SIZE_SINGLE = /^(cover|contain)$/;
const KEYWORD = /^(inherit|initial)$/i;

interface BackgroundResult {
  attachment?: string;
  clip?: string;
  image?: string;
  repeat?: string;
  color?: string;
  position?: string;
  size?: string;
}

const normalizeUrl = (value: string): string =>
  value.replace(cssUrlRegex(), (match: string) =>
    match.replace(/^url\(\s+/, "url(").replace(/\s+\)$/, ")")
  );

export default function background(value: string): Record<string, string> | undefined {
  // Check if this needs advanced multi-layer parsing
  if (needsAdvancedParser(value)) {
    const layeredResult = parseBackgroundLayers(value);
    if (layeredResult) {
      return reconstructLayers(layeredResult.layers, layeredResult.color);
    }
    return undefined; // Advanced parsing failed
  }

  // Use existing single-layer parsing logic
  const result: BackgroundResult = {};
  const values = normalizeUrl(normalizeColor(value))
    .replace(/\(.*\/.*\)|(\/)+/g, (match: string, group1: string) => (!group1 ? match : " / "))
    .split(/\s+/);

  const first = values[0];

  if (values.length === 1 && KEYWORD.test(first)) {
    return {
      "background-attachment": first,
      "background-clip": first,
      "background-image": first,
      "background-repeat": first,
      "background-color": first,
      "background-position": first,
      "background-size": first,
    };
  }

  for (let i = 0; i < values.length; i++) {
    let v = values[i];

    if (ATTACHMENT.test(v)) {
      if (result.attachment) return;
      result.attachment = v;
    } else if (BOX.test(v)) {
      if (result.clip) return;
      result.clip = v;
    } else if (IMAGE.test(v)) {
      if (result.image) return;
      result.image = v;
    } else if (REPEAT_SINGLE.test(v)) {
      if (result.repeat) return;
      result.repeat = v;
    } else if (REPEAT_DOUBLE.test(v)) {
      if (result.repeat) return;

      const n = values[i + 1];

      if (n && REPEAT_DOUBLE.test(n)) {
        v += ` ${n}`;
        i++;
      }

      result.repeat = v;
    } else if (isColor(v)) {
      if (result.color) return;
      result.color = v;
    } else if (POSITION_HORIZONTAL.test(v) || POSITION_VERTICAL.test(v) || isLength(v)) {
      if (result.position) return;

      const n = values[i + 1];
      const isHorizontal = POSITION_HORIZONTAL.test(v) || isLength(v);
      const isVertical = n && (POSITION_VERTICAL.test(n) || isLength(n));

      if (isHorizontal && isVertical) {
        result.position = `${v} ${n}`;
        i++;
      } else {
        result.position = v;
      }

      const nextV = values[i + 1];

      if (nextV === "/") {
        i += 2;
        const sizeV = values[i];

        if (SIZE_SINGLE.test(sizeV)) {
          result.size = sizeV;
        } else if (sizeV === "auto" || isLength(sizeV)) {
          let sizeValue = sizeV;
          const sizeN = values[i + 1];

          if (sizeN === "auto" || isLength(sizeN)) {
            sizeValue += ` ${sizeN}`;
            i++;
          }

          result.size = sizeValue;
        } else {
          return;
        }
      }
    } else {
      return;
    }
  }

  const finalResult: Record<string, string> = {};
  for (const key in result) {
    if (result[key as keyof BackgroundResult]) {
      finalResult[`background-${key}`] = result[key as keyof BackgroundResult] as string;
    }
  }
  return finalResult;
}


=== File: src/border-radius.ts ===
// b_path:: src/border-radius.ts
const directional = (value: string): Record<string, string> | undefined => {
  const values = value.split(/\s+/);

  if (values.length === 1) values.splice(0, 1, ...Array.from({ length: 4 }, () => values[0]));
  else if (values.length === 2) values.push(...values);
  else if (values.length === 3) values.push(values[1]);
  else if (values.length > 4) return;

  return ["top-left", "top-right", "bottom-right", "bottom-left"].reduce(
    (acc: Record<string, string>, direction: string, i: number) => {
      acc[direction] = values[i];
      return acc;
    },
    {}
  );
};

const borderRadius = (value: string): Record<string, string> | undefined => {
  const longhand = directional(value);

  if (!longhand) return;

  const result: Record<string, string> = {};
  for (const key in longhand) {
    result[`border-${key}-radius`] = longhand[key];
  }
  return result;
};

export default borderRadius;


=== File: src/border.ts ===
// b_path:: src/border.ts
import directional from "./directional";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

interface BorderProperties {
  width?: string;
  style?: string;
  color?: string;
}

type BorderFunction = {
  (value: string): Record<string, string> | undefined;
  width: (value: string) => Record<string, string> | undefined;
  style: (value: string) => Record<string, string> | undefined;
  color: (value: string) => Record<string, string> | undefined;
  top: (value: string) => Record<string, string> | undefined;
  right: (value: string) => Record<string, string> | undefined;
  bottom: (value: string) => Record<string, string> | undefined;
  left: (value: string) => Record<string, string> | undefined;
};

const suffix =
  (suffix: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = directional(value);

    if (!longhand) return;

    const result: Record<string, string> = {};
    for (const key in longhand) {
      result[`border-${key}-${suffix}`] = longhand[key];
    }
    return result;
  };

const direction =
  (direction: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = all(value);

    if (!longhand) return;

    const filtered: Record<string, string> = {};
    for (const key in longhand) {
      if (longhand[key as keyof BorderProperties]) {
        filtered[`border-${direction}-${key}`] = longhand[key as keyof BorderProperties] as string;
      }
    }
    return filtered;
  };

const all = (value: string): BorderProperties | undefined => {
  const values = normalizeColor(value).split(/\s+/);
  const first = values[0];

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(first)) {
    return {
      width: first,
      style: first,
      color: first,
    };
  }

  const result: BorderProperties = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (WIDTH.test(v) || isLength(v)) {
      if (result.width) return;
      result.width = v;
    } else if (STYLE.test(v)) {
      if (result.style) return;
      result.style = v;
    } else if (isColor(v)) {
      if (result.color) return;
      result.color = v;
    } else {
      return;
    }
  }

  return result;
};

const border: BorderFunction = (value: string): Record<string, string> | undefined => {
  const longhand = all(value);

  if (!longhand) return;

  const result: Record<string, string> = {};
  for (const key of Object.keys(longhand) as (keyof BorderProperties)[]) {
    const propFunction = border[key as keyof BorderFunction] as (
      value: string
    ) => Record<string, string> | undefined;
    const propValue = longhand[key];
    if (propValue) {
      const props = propFunction(propValue);
      if (props) {
        Object.assign(result, props);
      }
    }
  }
  return result;
};

border.width = suffix("width");
border.style = suffix("style");
border.color = suffix("color");
border.top = direction("top");
border.right = direction("right");
border.bottom = direction("bottom");
border.left = direction("left");

export default border;


=== File: src/color-utils.ts ===
// b_path:: src/color-utils.ts
// Color utility functions - replacing external dependencies for better self-containment

export const CSS_COLOR_NAMES: Record<string, string> = {
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#00FFFF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000000",
  blanchedalmond: "#FFEBCD",
  blue: "#0000FF",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#00FFFF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  darkgreen: "#006400",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#FF00FF",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  lightgreen: "#90EE90",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#00FF00",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#FF00FF",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#FF0000",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFFFFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FFFF00",
  yellowgreen: "#9ACD32",
};

export function cssUrlRegex(): RegExp {
  return /url\((.*?)\)/gi;
}

export function hexColorRegex(opts?: { strict?: boolean }): RegExp {
  opts = opts && typeof opts === "object" ? opts : {};
  return opts.strict
    ? /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/i
    : /#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})\b/gi;
}

export function hslRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)$/
    : /hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)/gi;
}

export function hslaRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/
    : /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)/gi;
}

export function rgbRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/
    : /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/gi;
}

export function rgbaRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/
    : /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/gi;
}


=== File: src/column-rule.ts ===
// b_path:: src/column-rule.ts
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function columnRule(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(values[0])) {
    return {
      "column-rule-width": values[0],
      "column-rule-style": values[0],
      "column-rule-color": values[0],
    };
  }

  const result: Record<string, string> = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (isLength(v) || WIDTH.test(v)) {
      if (result["column-rule-width"]) return;
      result["column-rule-width"] = v;
    } else if (STYLE.test(v)) {
      if (result["column-rule-style"]) return;
      result["column-rule-style"] = v;
    } else if (isColor(v)) {
      if (result["column-rule-color"]) return;
      result["column-rule-color"] = v;
    } else {
      return;
    }
  }

  return result;
}


=== File: src/columns.ts ===
// b_path:: src/columns.ts
import isLength from "./is-length";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "column-width": value,
      "column-count": value,
    };
  }

  // Split values on whitespace
  const values = value.trim().split(/\s+/);

  // Validate value count - max 2 values
  if (values.length > 2) {
    return undefined;
  }

  // Regex patterns for type detection
  const INTEGER = /^[0-9]+$/;
  const KEYWORD = /^(auto)$/i;

  const result: Record<string, string> = {};

  // Separate specific values from auto values
  const specificValues: Array<{ value: string; type: "width" | "count" }> = [];
  const autoValues: string[] = [];

  for (const val of values) {
    if (KEYWORD.test(val)) {
      autoValues.push(val);
    } else if (INTEGER.test(val)) {
      specificValues.push({ value: val, type: "count" });
    } else if (isLength(val)) {
      specificValues.push({ value: val, type: "width" });
    } else {
      return undefined; // Invalid value
    }
  }

  // Check for conflicts in specific values
  if (
    specificValues.filter((v) => v.type === "width").length > 1 ||
    specificValues.filter((v) => v.type === "count").length > 1
  ) {
    return undefined; // Multiple values for same property
  }

  // Assign specific values first
  for (const { value, type } of specificValues) {
    if (type === "count" && value === "0") {
      return undefined; // column-count cannot be 0
    }
    result[`column-${type}`] = value;
  }

  // Assign auto values to remaining properties
  for (const autoValue of autoValues) {
    if (!result["column-width"]) {
      result["column-width"] = autoValue;
    } else if (!result["column-count"]) {
      result["column-count"] = autoValue;
    } else {
      return undefined; // No available property for auto
    }
  }

  return result;
};


=== File: src/contain-intrinsic-size.ts ===
// b_path:: src/contain-intrinsic-size.ts
import isLength from "./is-length";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "contain-intrinsic-width": value,
      "contain-intrinsic-height": value,
    };
  }

  // Split values on whitespace
  const tokens = value.trim().split(/\s+/);

  // Validate token count - max 4 tokens (for two auto pairs)
  if (tokens.length > 4 || tokens.length === 0) {
    return undefined;
  }

  const result: Record<string, string> = {};

  // Parse tokens into width and height values
  let i = 0;
  const parseValue = (): string | undefined => {
    if (i >= tokens.length) return undefined;

    const token = tokens[i++];
    if (token.toLowerCase() === "auto") {
      if (i >= tokens.length) return undefined; // auto must be followed by something
      const nextToken = tokens[i++];
      if (nextToken.toLowerCase() === "none") {
        return "auto none";
      } else if (isLength(nextToken)) {
        return `auto ${nextToken}`;
      } else {
        return undefined; // invalid after auto
      }
    } else if (token.toLowerCase() === "none") {
      return "none";
    } else if (isLength(token)) {
      return token;
    } else {
      return undefined; // invalid token
    }
  };

  // Parse width value
  const widthValue = parseValue();
  if (widthValue === undefined) return undefined;

  // Parse height value (if present)
  const heightValue = parseValue();

  // If only one value provided, apply to both
  if (heightValue === undefined) {
    result["contain-intrinsic-width"] = widthValue;
    result["contain-intrinsic-height"] = widthValue;
  } else {
    // Two values provided
    result["contain-intrinsic-width"] = widthValue;
    result["contain-intrinsic-height"] = heightValue;
  }

  // Ensure no extra tokens
  if (i !== tokens.length) return undefined;

  return result;
};


=== File: src/directional.ts ===
// b_path:: src/directional.ts
export default function directional(value: string): Record<string, string> | undefined {
  const values = value.split(/\s+/);

  if (values.length === 1) values.splice(0, 1, ...Array.from({ length: 4 }, () => values[0]));
  else if (values.length === 2) values.push(...values);
  else if (values.length === 3) values.push(values[1]);
  else if (values.length > 4) return;

  return ["top", "right", "bottom", "left"].reduce(
    (acc: Record<string, string>, direction: string, i: number) => {
      acc[direction] = values[i];
      return acc;
    },
    {}
  );
}


=== File: src/flex-flow.ts ===
// b_path:: src/flex-flow.ts
export default function (value: string): Record<string, string> | undefined {
  // Handle global CSS keywords first
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "flex-direction": value,
      "flex-wrap": value,
    };
  }

  // Parse normal values
  const parts = value.trim().split(/\s+/);
  if (parts.length > 2) return undefined;

  // Define keyword patterns
  const directionPattern = /^(row|row-reverse|column|column-reverse)$/i;
  const wrapPattern = /^(nowrap|wrap|wrap-reverse)$/i;

  // Value classification logic
  let direction: string | undefined;
  let wrap: string | undefined;

  for (const part of parts) {
    if (directionPattern.test(part)) {
      if (direction !== undefined) return undefined; // duplicate
      direction = part;
    } else if (wrapPattern.test(part)) {
      if (wrap !== undefined) return undefined; // duplicate
      wrap = part;
    } else {
      return undefined; // invalid
    }
  }

  // Return result
  const result: Record<string, string> = {};
  if (direction) result["flex-direction"] = direction;
  if (wrap) result["flex-wrap"] = wrap;
  return Object.keys(result).length > 0 ? result : undefined;
}


=== File: src/flex.ts ===
// b_path:: src/flex.ts
import isLength from "./is-length";

export default function (value: string): Record<string, string> | undefined {
  // Handle global CSS keywords
  if (/^(inherit|unset|revert)$/i.test(value)) {
    return {
      "flex-grow": value,
      "flex-shrink": value,
      "flex-basis": value,
    };
  }

  // Special case for initial
  if (value === "initial") {
    return {
      "flex-grow": "0",
      "flex-shrink": "1",
      "flex-basis": "auto",
    };
  }

  // Handle special keyword values
  if (value === "none") {
    return {
      "flex-grow": "0",
      "flex-shrink": "0",
      "flex-basis": "auto",
    };
  }

  if (value === "auto") {
    return {
      "flex-grow": "1",
      "flex-shrink": "1",
      "flex-basis": "auto",
    };
  }

  // Parse normal values
  const parts = value.trim().split(/\s+/);
  if (parts.length > 3 || parts.length === 0) return undefined;

  // Define value type detection patterns
  const numberPattern = /^[+-]?([0-9]*\.)?[0-9]+$/;
  const flexBasisKeywordPattern = /^(auto|content|max-content|min-content|fit-content)$/i;
  const fitContentFn = /^fit-content\(\s*[^)]+\s*\)$/i;

  // Classify each value by type
  const classified: Array<{ value: string; type: "number" | "basis" }> = [];
  for (const part of parts) {
    if (numberPattern.test(part)) {
      classified.push({ value: part, type: "number" });
    } else if (flexBasisKeywordPattern.test(part) || isLength(part) || fitContentFn.test(part)) {
      classified.push({ value: part, type: "basis" });
    } else {
      return undefined;
    }
  }

  // Handle unitless zero as basis in three-value form
  if (classified.length === 3 && classified[2].type === "number" && isLength(classified[2].value)) {
    classified[2] = { type: "basis", value: classified[2].value };
  }

  // Apply expansion rules based on value count
  if (classified.length === 1) {
    const [val] = classified;
    if (val.type === "number") {
      return {
        "flex-grow": val.value,
        "flex-shrink": "1",
        "flex-basis": "0%",
      };
    } else {
      return {
        "flex-grow": "1",
        "flex-shrink": "1",
        "flex-basis": val.value,
      };
    }
  } else if (classified.length === 2) {
    const [first, second] = classified;
    if (first.type === "number" && second.type === "number") {
      return {
        "flex-grow": first.value,
        "flex-shrink": second.value,
        "flex-basis": "0%",
      };
    } else if (first.type === "number" && second.type === "basis") {
      return {
        "flex-grow": first.value,
        "flex-shrink": "1",
        "flex-basis": second.value,
      };
    } else {
      return undefined;
    }
  } else if (classified.length === 3) {
    const [first, second, third] = classified;
    if (first.type === "number" && second.type === "number" && third.type === "basis") {
      return {
        "flex-grow": first.value,
        "flex-shrink": second.value,
        "flex-basis": third.value,
      };
    } else {
      return undefined;
    }
  }

  return undefined;
}


=== File: src/font.ts ===
// b_path:: src/font.ts
/**
 * Copied from https://github.com/bramstein/css-font-parser
 */

/**
 * @enum {number}
 */
const states = {
  VARIATION: 1,
  LINE_HEIGHT: 2,
  FONT_FAMILY: 3,
};

interface FontResult {
  "font-family": string[];
  "font-size"?: string;
  "line-height"?: string;
  "font-style"?: string;
  "font-weight"?: string;
  "font-variant"?: string;
  "font-stretch"?: string;
}

function parse(input: string): FontResult | null {
  let state = states.VARIATION;
  let buffer = "";
  const result: FontResult = {
    "font-family": [],
  };

  for (let i = 0; i < input.length; i += 1) {
    const c = input.charAt(i);
    if (state === states.FONT_FAMILY && (c === '"' || c === "'")) {
      let index = i + 1;

      // consume the entire string
      do {
        index = input.indexOf(c, index) + 1;
        if (!index) {
          // If a string is not closed by a ' or " return null.
          // TODO: Check to see if this is correct.
          return null;
        }
      } while (input.charAt(index - 2) === "\\");

      result["font-family"].push(input.slice(i + 1, index - 1).replace(/\\('|")/g, "$1"));

      i = index - 1;
      buffer = "";
    } else if (state === states.FONT_FAMILY && c === ",") {
      if (!/^\s*$/.test(buffer)) {
        result["font-family"].push(buffer.replace(/^\s+|\s+$/, "").replace(/\s+/g, " "));
        buffer = "";
      }
    } else if (state === states.VARIATION && (c === " " || c === "/")) {
      if (
        /^((xx|x)-large|(xx|s)-small|small|large|medium)$/.test(buffer) ||
        /^(larg|small)er$/.test(buffer) ||
        /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/.test(buffer)
      ) {
        state = c === "/" ? states.LINE_HEIGHT : states.FONT_FAMILY;
        result["font-size"] = buffer;
      } else if (/^(italic|oblique)$/.test(buffer)) {
        result["font-style"] = buffer;
      } else if (/^small-caps$/.test(buffer)) {
        result["font-variant"] = buffer;
      } else if (/^(bold(er)?|lighter|normal|[1-9]00)$/.test(buffer)) {
        result["font-weight"] = buffer;
      } else if (/^((ultra|extra|semi)-)?(condensed|expanded)$/.test(buffer)) {
        result["font-stretch"] = buffer;
      }
      buffer = "";
    } else if (state === states.LINE_HEIGHT && c === " ") {
      if (
        /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)?$/.test(buffer)
      ) {
        result["line-height"] = buffer;
      }
      state = states.FONT_FAMILY;
      buffer = "";
    } else {
      buffer += c;
    }
  }

  if (state === states.FONT_FAMILY && !/^\s*$/.test(buffer)) {
    result["font-family"].push(buffer.replace(/^\s+|\s+$/, "").replace(/\s+/g, " "));
  }

  if (result["font-size"] && result["font-family"].length) {
    return result;
  } else {
    return null;
  }
}

export default function font(input: string): Record<string, string> | undefined {
  if (/^(inherit|initial)$/.test(input)) {
    return {
      "font-size": input,
      "line-height": input,
      "font-style": input,
      "font-weight": input,
      "font-variant": input,
      "font-stretch": input,
      "font-family": input,
    };
  }

  input = input.replace(/\s*\/\s*/, "/");
  const result = parse(input);

  if (result) {
    const finalResult: Record<string, string> = {};
    for (const key in result) {
      if (key === "font-family") {
        finalResult[key] = result[key]
          .map((family: string) =>
            /^(serif|sans-serif|monospace|cursive|fantasy)$/.test(family) ? family : `"${family}"`
          )
          .join(", ");
      } else if (result[key as keyof FontResult]) {
        finalResult[key] = result[key as keyof FontResult] as string;
      }
    }
    return finalResult;
  }

  return undefined;
}


=== File: src/grid-area.ts ===
// b_path:: src/grid-area.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-row-start": value,
      "grid-column-start": value,
      "grid-row-end": value,
      "grid-column-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 4 parts
  if (parts.length > 4) {
    return undefined;
  }

  // Validate all parts
  for (const part of parts) {
    if (!parseGridLine(part.trim())) {
      return undefined;
    }
  }

  let rowStart: string, columnStart: string, rowEnd: string, columnEnd: string;

  if (parts.length === 1) {
    // 1 value: row-start (or all if custom-ident)
    const val = parts[0].trim();
    if (/^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(val) && !/^(auto|span|\d)/i.test(val)) {
      // Custom-ident: all four get the same value
      rowStart = columnStart = rowEnd = columnEnd = val;
    } else {
      // Otherwise: row-start gets value, others auto
      rowStart = val;
      columnStart = "auto";
      rowEnd = "auto";
      columnEnd = "auto";
    }
  } else if (parts.length === 2) {
    // 2 values: row-start / column-start
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = getDefaultEnd(rowStart);
    columnEnd = getDefaultEnd(columnStart);
  } else if (parts.length === 3) {
    // 3 values: row-start / column-start / row-end
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = parts[2].trim();
    columnEnd = getDefaultEnd(columnStart);
  } else {
    // 4 values: row-start / column-start / row-end / column-end
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = parts[2].trim();
    columnEnd = parts[3].trim();
  }

  return {
    "grid-row-start": rowStart,
    "grid-column-start": columnStart,
    "grid-row-end": rowEnd,
    "grid-column-end": columnEnd,
  };
};


=== File: src/grid-column.ts ===
// b_path:: src/grid-column.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-column-start": value,
      "grid-column-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 2 parts
  if (parts.length > 2) {
    return undefined;
  }

  // Handle single value
  if (parts.length === 1) {
    const startValue = parts[0].trim();
    if (!parseGridLine(startValue)) {
      return undefined;
    }
    const endValue = getDefaultEnd(startValue);
    return {
      "grid-column-start": startValue,
      "grid-column-end": endValue,
    };
  }

  // Handle two values
  if (parts.length === 2) {
    const startValue = parts[0].trim();
    const endValue = parts[1].trim();
    if (!parseGridLine(startValue) || !parseGridLine(endValue)) {
      return undefined;
    }
    return {
      "grid-column-start": startValue,
      "grid-column-end": endValue,
    };
  }

  return undefined;
};


=== File: src/grid-line.ts ===
// b_path:: src/grid-line.ts

export function isCustomIdent(s: string): boolean {
  return /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(s);
}

function isInteger(s: string): boolean {
  return /^[+-]?[0-9]+$/.test(s) && Number(s) !== 0;
}

export function parseGridLine(value: string): boolean {
  const tokens = value.trim().split(/\s+/);
  if (tokens.length === 0) return false;

  if (tokens[0] === "span") {
    if (tokens.length < 2 || tokens.length > 3) return false;
    const rest = tokens.slice(1);
    let seenInt = false;
    let seenIdent = false;
    for (const token of rest) {
      if (isInteger(token)) {
        if (seenInt) return false;
        seenInt = true;
      } else if (isCustomIdent(token)) {
        if (seenIdent) return false;
        seenIdent = true;
      } else {
        return false;
      }
    }
    return seenInt || seenIdent;
  } else {
    if (tokens.length > 2) return false;
    let seenInt = false;
    let seenIdent = false;
    for (const token of tokens) {
      if (isInteger(token)) {
        if (seenInt) return false;
        seenInt = true;
      } else if (isCustomIdent(token)) {
        if (seenIdent) return false;
        seenIdent = true;
      } else {
        return false;
      }
    }
    return seenInt || seenIdent;
  }
}

export function getDefaultEnd(start: string): string {
  return isCustomIdent(start) ? start : "auto";
}


=== File: src/grid-row.ts ===
// b_path:: src/grid-row.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-row-start": value,
      "grid-row-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 2 parts
  if (parts.length > 2) {
    return undefined;
  }

  // Handle single value
  if (parts.length === 1) {
    const startValue = parts[0].trim();
    if (!parseGridLine(startValue)) {
      return undefined;
    }
    const endValue = getDefaultEnd(startValue);
    return {
      "grid-row-start": startValue,
      "grid-row-end": endValue,
    };
  }

  // Handle two values
  if (parts.length === 2) {
    const startValue = parts[0].trim();
    const endValue = parts[1].trim();
    if (!parseGridLine(startValue) || !parseGridLine(endValue)) {
      return undefined;
    }
    return {
      "grid-row-start": startValue,
      "grid-row-end": endValue,
    };
  }

  return undefined;
};


=== File: src/grid.ts ===
// b_path:: src/grid.ts

import * as csstree from "css-tree";

// CSS default values for grid properties
export const GRID_DEFAULTS = {
  "grid-template-rows": "none",
  "grid-template-columns": "none",
  "grid-template-areas": "none",
  "grid-auto-rows": "auto",
  "grid-auto-columns": "auto",
  "grid-auto-flow": "row",
} as const;

/**
 * Parses value and returns segments and slash count
 */
function parseValueAndGetSegments(
  value: string
): { leftSegment: csstree.CssNode[]; rightSegment: csstree.CssNode[]; slashCount: number } | null {
  try {
    const ast = csstree.parse(value.trim(), { context: "value" }) as csstree.Value;

    // Find top-level / operator positions
    const slashIndices: number[] = [];

    csstree.walk(ast, {
      visit: "Value",
      enter: (node: csstree.Value) => {
        if (node.children) {
          let index = 0;
          node.children.forEach((child) => {
            if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
              slashIndices.push(index);
            }
            index++;
          });
        }
      },
    });

    const slashCount = slashIndices.length;
    if (slashCount > 1) {
      return null; // Multiple slashes not allowed
    }

    const childrenArray = listToArray(ast.children);
    if (slashCount === 0) {
      return { leftSegment: childrenArray, rightSegment: [], slashCount: 0 };
    }

    const slashIndex = slashIndices[0];
    const leftSegment = childrenArray.slice(0, slashIndex);
    const rightSegment = childrenArray.slice(slashIndex + 1);

    return { leftSegment, rightSegment, slashCount };
  } catch {
    return null;
  }
}

/**
 * Detects which grid shorthand form is being used
 */
function detectGridForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): "template" | "explicit-rows" | "explicit-columns" | null {
  if (rightSegment.length === 0) {
    // No slash, check if it's valid track list or ASCII art
    return "template";
  }

  // Check for auto-flow in each segment
  let hasAutoFlowLeft = false;
  let hasAutoFlowRight = false;

  for (const node of leftSegment) {
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      hasAutoFlowLeft = true;
      break;
    }
  }

  for (const node of rightSegment) {
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      hasAutoFlowRight = true;
      break;
    }
  }

  if (hasAutoFlowRight) {
    return "explicit-rows";
  } else if (hasAutoFlowLeft) {
    return "explicit-columns";
  } else {
    return "template";
  }
}

/**
 * Helper to convert List to array
 */
function listToArray<T>(list: csstree.List<T>): T[] {
  const arr: T[] = [];
  for (const item of list) {
    arr.push(item);
  }
  return arr;
}

/**
 * Separates areas (strings) and tracks (other nodes) from a segment
 */
function separateAreasAndTracks(segmentNodes: csstree.CssNode[]): {
  areas: string | undefined;
  tracks: string | undefined;
} {
  const strings: string[] = [];
  const tracks: csstree.CssNode[] = [];

  for (const node of segmentNodes) {
    if (node.type === "String") {
      strings.push((node as csstree.StringNode).value);
    } else if (node.type !== "WhiteSpace") {
      tracks.push(node);
    }
  }

  let areas: string | undefined;
  if (strings.length > 0) {
    // Validate that all rows have the same number of columns
    const rows = strings.map((s) => s.trim().split(/\s+/));
    const columnCount = rows[0]?.length || 0;
    if (columnCount === 0 || !rows.every((row) => row.length === columnCount)) {
      return { areas: undefined, tracks: undefined }; // Invalid
    }
    areas = strings.map((s) => `"${s.trim()}"`).join(" ");
  }

  let tracksStr: string | undefined;
  if (tracks.length > 0) {
    tracksStr = parseTrackList(tracks);
  }

  return { areas, tracks: tracksStr };
}

/**
 * Parses track list (rows or columns) into CSS string
 */
function parseTrackList(segmentNodes: csstree.CssNode[]): string | undefined {
  const validNodes: csstree.CssNode[] = [];

  for (const node of segmentNodes) {
    if (
      node.type === "Identifier" &&
      ["auto", "min-content", "max-content"].includes((node as csstree.Identifier).name)
    ) {
      validNodes.push(node);
    } else if (node.type === "Dimension") {
      validNodes.push(node);
    } else if (node.type === "Percentage") {
      validNodes.push(node);
    } else if (
      node.type === "Function" &&
      ["repeat", "minmax", "fit-content"].includes((node as csstree.FunctionNode).name)
    ) {
      validNodes.push(node);
    } else if (node.type === "Number" && (node as csstree.NumberNode).value === "0") {
      validNodes.push(node);
    } else if (node.type === "Parentheses") {
      // Named grid lines like [line1]
      validNodes.push(node);
    }
  }

  if (validNodes.length === 0) {
    return undefined;
  }

  // Generate CSS from the valid nodes
  const generatedParts: string[] = [];
  for (const node of validNodes) {
    generatedParts.push(csstree.generate(node));
  }

  return generatedParts.join(" ");
}

/**
 * Parses template form: <grid-template>
 */
function parseTemplateForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  let templateAreas: string | undefined;
  let templateRows: string | undefined;
  let templateColumns: string | undefined;

  if (rightSegment.length === 0) {
    // No slash - could be just rows, but not areas
    const { areas, tracks } = separateAreasAndTracks(leftSegment);
    if (areas) {
      return undefined; // Strings without slash not supported
    }
    templateRows = tracks;
    if (!templateRows) {
      return undefined; // Invalid
    }
  } else {
    const { areas: leftAreas, tracks: leftTracks } = separateAreasAndTracks(leftSegment);
    const { tracks: rightTracks } = separateAreasAndTracks(rightSegment);

    // Template form logic:
    // - If left has areas, then left areas + left tracks (as rows) + right columns
    // - If left has tracks but no areas, then left rows + right columns
    // - If no slash and left has areas, then just areas
    // - If no slash and left has tracks, then just rows

    if (leftAreas) {
      templateAreas = leftAreas;
      templateRows = leftTracks; // Interleaved track sizes become rows
      templateColumns = rightTracks;
      if (!templateColumns) {
        return undefined;
      }
    } else if (leftTracks) {
      templateRows = leftTracks;
      templateColumns = rightTracks;
      if (!templateColumns) {
        return undefined;
      }
    } else {
      return undefined; // Invalid
    }
  }

  return {
    "grid-template-rows": templateRows || GRID_DEFAULTS["grid-template-rows"],
    "grid-template-columns": templateColumns || GRID_DEFAULTS["grid-template-columns"],
    "grid-template-areas": templateAreas || GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": GRID_DEFAULTS["grid-auto-flow"],
  };
}

/**
 * Parses explicit rows form: <rows> / auto-flow [dense] [<auto-columns>]
 */
function parseExplicitRowsForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  // Check if right segment starts with auto-flow
  let firstNonWhiteSpace: csstree.CssNode | undefined;
  for (const node of rightSegment) {
    if (node.type !== "WhiteSpace") {
      firstNonWhiteSpace = node;
      break;
    }
  }
  if (
    !firstNonWhiteSpace ||
    firstNonWhiteSpace.type !== "Identifier" ||
    (firstNonWhiteSpace as csstree.Identifier).name !== "auto-flow"
  ) {
    return undefined;
  }

  // Left side: template rows
  const templateRows = parseTrackList(leftSegment);
  if (!templateRows) {
    return undefined;
  }

  // Right side: auto-flow [dense] [auto-columns]
  let autoFlow = "column";
  let autoColumns: string | undefined;

  // Find auto-flow and dense
  let hasDense = false;
  let autoColumnsStart = -1;

  for (let i = 0; i < rightSegment.length; i++) {
    const node = rightSegment[i];
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      // Next might be dense
      if (
        i + 1 < rightSegment.length &&
        rightSegment[i + 1].type === "Identifier" &&
        (rightSegment[i + 1] as csstree.Identifier).name === "dense"
      ) {
        hasDense = true;
        autoColumnsStart = i + 2;
      } else {
        autoColumnsStart = i + 1;
      }
      break;
    }
  }

  if (hasDense) {
    autoFlow = "column dense";
  }

  // Parse auto-columns if present
  if (autoColumnsStart >= 0 && autoColumnsStart < rightSegment.length) {
    const autoColumnsSegment = rightSegment.slice(autoColumnsStart);
    autoColumns = parseTrackList(autoColumnsSegment);
  }

  return {
    "grid-template-rows": templateRows,
    "grid-template-columns": GRID_DEFAULTS["grid-template-columns"],
    "grid-template-areas": GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": autoColumns || GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": autoFlow,
  };
}

/**
 * Parses explicit columns form: auto-flow [dense] [<auto-rows>] / <columns>
 */
function parseExplicitColumnsForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  // Check if left segment starts with auto-flow
  let firstNonWhiteSpace: csstree.CssNode | undefined;
  for (const node of leftSegment) {
    if (node.type !== "WhiteSpace") {
      firstNonWhiteSpace = node;
      break;
    }
  }
  if (
    !firstNonWhiteSpace ||
    firstNonWhiteSpace.type !== "Identifier" ||
    (firstNonWhiteSpace as csstree.Identifier).name !== "auto-flow"
  ) {
    return undefined;
  }

  // Right side: template columns
  const templateColumns = parseTrackList(rightSegment);
  if (!templateColumns) {
    return undefined;
  }

  // Left side: auto-flow [dense] [auto-rows]
  let autoFlow = "row";
  let autoRows: string | undefined;

  // Find auto-flow and dense
  let hasDense = false;
  let autoRowsStart = -1;

  for (let i = 0; i < leftSegment.length; i++) {
    const node = leftSegment[i];
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      // Next might be dense
      if (
        i + 1 < leftSegment.length &&
        leftSegment[i + 1].type === "Identifier" &&
        (leftSegment[i + 1] as csstree.Identifier).name === "dense"
      ) {
        hasDense = true;
        autoRowsStart = i + 2;
      } else {
        autoRowsStart = i + 1;
      }
      break;
    }
  }

  if (hasDense) {
    autoFlow = "row dense";
  }

  // Parse auto-rows if present
  if (autoRowsStart >= 0 && autoRowsStart < leftSegment.length) {
    const autoRowsSegment = leftSegment.slice(autoRowsStart);
    autoRows = parseTrackList(autoRowsSegment);
  }

  return {
    "grid-template-rows": GRID_DEFAULTS["grid-template-rows"],
    "grid-template-columns": templateColumns,
    "grid-template-areas": GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": autoRows || GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": autoFlow,
  };
}

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-template-rows": value,
      "grid-template-columns": value,
      "grid-template-areas": value,
      "grid-auto-rows": value,
      "grid-auto-columns": value,
      "grid-auto-flow": value,
    };
  }

  // Handle none keyword
  if (value.trim().toLowerCase() === "none") {
    return { ...GRID_DEFAULTS };
  }

  // Parse value and get segments
  const segments = parseValueAndGetSegments(value);
  if (!segments) {
    return undefined; // Invalid (e.g., multiple slashes)
  }

  // Detect form and parse accordingly
  const form = detectGridForm(segments.leftSegment, segments.rightSegment);
  switch (form) {
    case "template":
      return parseTemplateForm(segments.leftSegment, segments.rightSegment);
    case "explicit-rows":
      return parseExplicitRowsForm(segments.leftSegment, segments.rightSegment);
    case "explicit-columns":
      return parseExplicitColumnsForm(segments.leftSegment, segments.rightSegment);
    default:
      return undefined;
  }
};


=== File: src/index.ts ===
// b_path:: src/index.ts

import animation from "./animation";
import background from "./background";
import border from "./border";
import borderRadius from "./border-radius";
import columnRule from "./column-rule";
import columns from "./columns";
import containIntrinsicSize from "./contain-intrinsic-size";
import directional from "./directional";
import flex from "./flex";
import flexFlow from "./flex-flow";
import font from "./font";
import grid from "./grid";
import gridArea from "./grid-area";
import gridColumn from "./grid-column";
import gridRow from "./grid-row";
import listStyle from "./list-style";
import mask from "./mask";
import offset from "./offset";
import outline from "./outline";
import overflow from "./overflow";
import placeContent from "./place-content";
import placeItems from "./place-items";
import placeSelf from "./place-self";
import type { ExpandOptions, ExpandResult } from "./schema";
import textDecoration from "./text-decoration";
import textEmphasis from "./text-emphasis";
import transition from "./transition";
import { validate } from "./validate";

function parseInputString(input: string): string[] {
  // Split on semicolons and filter out empty declarations
  return input
    .split(";")
    .map((decl) => decl.trim())
    .filter((decl) => decl.length > 0);
}

function parseCssDeclaration(declaration: string): { property: string; value: string } | null {
  const trimmed = declaration.trim();
  const colonIndex = trimmed.indexOf(":");

  if (colonIndex === -1) return null;

  const property = trimmed.slice(0, colonIndex).trim();
  const value = trimmed.slice(colonIndex + 1).trim();

  if (!property || !value) return null;

  return { property, value };
}

const prefix =
  (prefix: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = directional(value);

    if (!longhand) return;

    const result: Record<string, string> = {};
    for (const key in longhand) {
      result[`${prefix}-${key}`] = longhand[key];
    }
    return result;
  };

const shorthand: Record<string, (value: string) => Record<string, string> | undefined> = {
  animation: animation,
  background: background,
  border: border,
  "border-bottom": border.bottom,
  "border-color": border.color,
  "border-left": border.left,
  "border-radius": borderRadius,
  "border-right": border.right,
  "border-style": border.style,
  "border-top": border.top,
  "border-width": border.width,
  columns: columns,
  "column-rule": columnRule,
  "contain-intrinsic-size": containIntrinsicSize,
  flex: flex,
  "flex-flow": flexFlow,
  font: font,
  grid: grid,
  "grid-area": gridArea,
  "grid-column": gridColumn,
  "grid-row": gridRow,
  inset: directional,
  "list-style": listStyle,
  mask: mask,
  margin: prefix("margin"),
  offset: offset,
  outline: outline,
  overflow: overflow,
  padding: prefix("padding"),
  "place-content": placeContent,
  "place-items": placeItems,
  "place-self": placeSelf,
  "text-decoration": textDecoration,
  "text-emphasis": textEmphasis,
  transition: transition,
};

function objectToCss(obj: Record<string, string>, indent: number, separator: string): string {
  const indentStr = " ".repeat(indent);
  return Object.entries(obj)
    .map(([key, value]) => `${indentStr}${key}: ${value};`)
    .join(separator);
}

export default function expand(input: string, options: Partial<ExpandOptions> = {}): ExpandResult {
  // Merge partial options with defaults from schema
  const { format = "css", indent = 0, separator = "\n" } = options;

  // Validate the input CSS directly (assume it's valid CSS)
  const validation = validate(input);

  const inputs = parseInputString(input);
  const results: (Record<string, string> | string)[] = [];

  for (const item of inputs) {
    const parsed = parseCssDeclaration(item);
    if (!parsed) {
      continue; // Skip invalid declarations
    }

    const { property, value } = parsed;
    const normalized = value.trim();
    const important = /\s+!important$/.test(normalized);
    const cleanValue = normalized.replace(/\s+!important$/, "");

    const parse = shorthand[property];
    const longhand = parse?.(cleanValue);

    if (!longhand) {
      // For non-shorthand properties, still include them in the result
      // but as-is (no expansion needed) - validation will catch invalid ones
      const result: Record<string, string> = {};
      result[property] = normalized;
      results.push(format === "css" ? objectToCss(result, indent, separator) : result);
      continue;
    }

    let result: Record<string, string>;
    if (important) {
      result = {};
      for (const key in longhand) {
        result[key] = `${longhand[key]} !important`;
      }
    } else {
      result = longhand;
    }

    if (format === "css") {
      results.push(objectToCss(result, indent, separator));
    } else {
      results.push(result);
    }
  }

  let finalResult:
    | Record<string, string>
    | string
    | (Record<string, string> | string)[]
    | undefined;

  if (results.length === 0) {
    finalResult = undefined;
  } else if (results.length === 1) {
    finalResult = results[0];
  } else {
    // For CSS format, join multiple results into a single string
    if (format === "css") {
      finalResult = results.join(separator);
    } else {
      finalResult = results;
    }
  }

  // Determine ok status: false if errors, true if warnings only or no issues
  const ok = validation.errors.length === 0;

  // Combine errors and warnings into issues - use proper typing from schemas
  const issues = [...validation.errors, ...validation.warnings];

  return {
    ok,
    result: finalResult,
    issues,
  };
}


=== File: src/is-angle.ts ===
// b_path:: src/is-angle.ts
const ANGLE = /^(\+|-)?([0-9]*\.?[0-9]+)(deg|rad|turn|grad)$/i;
const ZERO = /^(\+|-)?(0*\.)?0+$/;

export default function isAngle(value: string): boolean {
  return ANGLE.test(value) || ZERO.test(value);
}


=== File: src/is-color.ts ===
// b_path:: src/is-color.ts
import {
  CSS_COLOR_NAMES,
  hexColorRegex,
  hslaRegex,
  hslRegex,
  rgbaRegex,
  rgbRegex,
} from "./color-utils";

const HEX = new RegExp(`^${hexColorRegex().source}$`, "i");
const HSLA = hslaRegex({ exact: true });
const HSL = hslRegex({ exact: true });
const RGB = rgbRegex({ exact: true });
const RGBA = rgbaRegex({ exact: true });

export default function isColor(value: string): boolean {
  value = value.toLowerCase();

  // Support CSS custom property (var name)
  if (/^var\(\s*--[a-zA-Z0-9-_]+\s*\)$/.test(value)) {
    return true;
  }

  return (
    !!CSS_COLOR_NAMES[value] ||
    value === "currentcolor" ||
    value === "transparent" ||
    HEX.test(value) ||
    HSLA.test(value) ||
    HSL.test(value) ||
    RGB.test(value) ||
    RGBA.test(value)
  );
}


=== File: src/is-length.ts ===
// b_path:: src/is-length.ts
const LENGTH = /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/i;
const ZERO = /^(\+|-)?(0*\.)?0+$/;

export default function isLength(value: string): boolean {
  return LENGTH.test(value) || ZERO.test(value);
}


=== File: src/is-time.ts ===
// b_path:: src/is-time.ts
// Utility to detect CSS time values for transition-duration and transition-delay parsing
const TIME = /^[+-]?(\d*\.)?\d+(m?s)$/i;

export default function isTime(value: string): boolean {
  return TIME.test(value);
}


=== File: src/is-timing-function.ts ===
// b_path:: src/is-timing-function.ts
// Utility to detect CSS timing function values for transition-timing-function parsing
const TIMING_KEYWORDS = /^(ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end)$/i;
const TIMING_FUNCTIONS = /^(cubic-bezier|steps)\s*\(/i;

function hasBalancedParentheses(value: string): boolean {
  let openCount = 0;
  for (const char of value) {
    if (char === "(") {
      openCount++;
    } else if (char === ")") {
      openCount--;
      if (openCount < 0) {
        return false;
      }
    }
  }
  return openCount === 0;
}

export default function isTimingFunction(value: string): boolean {
  // Check for timing function keywords
  if (TIMING_KEYWORDS.test(value)) {
    return true;
  }

  // Check for timing function functions with balanced parentheses
  if (TIMING_FUNCTIONS.test(value)) {
    return hasBalancedParentheses(value);
  }

  return false;
}


=== File: src/list-style.ts ===
// b_path:: src/list-style.ts
import { cssUrlRegex } from "./color-utils";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const POSITION = /^(inside|outside)$/i;
const IMAGE = new RegExp(`^(${cssUrlRegex().source})$`, "i");
const COMMON_TYPE =
  /^(disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-alpha|lower-latin|upper-alpha|upper-latin|armenian|georgian|none)$/i;
const IDENT = /^[-_a-zA-Z][-_a-zA-Z0-9]*$/;
const STRING_VALUE = /^["'].*["']$/;

export default function listStyle(value: string): Record<string, string> | undefined {
  const normalizedValue = normalizeColor(value);

  // Special case: "none" alone sets both type and image to none
  if (normalizedValue === "none") {
    return {
      "list-style-type": "none",
      "list-style-image": "none",
    };
  }

  const values = normalizedValue.split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return {
      "list-style-type": values[0],
      "list-style-position": values[0],
      "list-style-image": values[0],
    };
  }

  const result: Record<string, string> = {};

  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (POSITION.test(v)) {
      if (result["list-style-position"]) return;
      result["list-style-position"] = v;
    } else if (IMAGE.test(v)) {
      if (result["list-style-image"]) return;
      result["list-style-image"] = v;
    } else if (COMMON_TYPE.test(v)) {
      if (result["list-style-type"]) return;
      result["list-style-type"] = v;
    } else {
      // Custom counter-style identifier or string value
      if (IDENT.test(v) || STRING_VALUE.test(v)) {
        if (result["list-style-type"]) return;
        result["list-style-type"] = v;
      } else {
        return;
      }
    }
  }

  return result;
}


=== File: src/mask-layers.ts ===
// b_path:: src/mask-layers.ts

import * as csstree from "css-tree";
import type { MaskLayer, MaskResult } from "./schema";

// CSS default values for mask properties
export const MASK_DEFAULTS = {
  image: "none",
  mode: "match-source",
  position: "0% 0%",
  size: "auto",
  repeat: "repeat",
  origin: "border-box",
  clip: "border-box",
  composite: "add",
} as const;

/**
 * Detects if a mask value needs advanced parsing (multi-layer masks)
 */
export function needsAdvancedParser(value: string): boolean {
  // Only use advanced parsing for actual multi-layer masks (comma-separated)
  // Must ignore commas inside parentheses/brackets (functions, rgba(), etc.)
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this indicates multiple layers
      return true;
    }
  }

  return false;
}

/**
 * Splits a mask value into layers, respecting nested functions
 */
function splitLayers(value: string): string[] {
  const layers: string[] = [];
  let currentLayer = "";
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this separates layers
      layers.push(currentLayer.trim());
      currentLayer = "";
      continue;
    }

    currentLayer += char;
  }

  // Add the last layer
  if (currentLayer.trim()) {
    layers.push(currentLayer.trim());
  }

  return layers;
}

/**
 * Parses a complex mask value using css-tree AST parsing
 */
export function parseMaskLayers(value: string): MaskResult | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer to extract all properties
    const layers: MaskLayer[] = [];

    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);
      if (!parsedLayer) {
        // Bail out if any layer fails parsing (stricter error handling)
        return undefined;
      }
      layers.push(parsedLayer);
    }

    return {
      layers,
    };
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Parses a single mask layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): MaskLayer | undefined {
  return parseSingleLayerWithCssTree(layerValue);
}

/**
 * Parses a single mask layer using css-tree AST parsing
 */
function parseSingleLayerWithCssTree(layerValue: string): MaskLayer | undefined {
  const result: MaskLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling position/size parsing
  const isValid = processCssChildren(children, result);

  // Return undefined if there were unrecognized tokens (stricter error handling)
  return isValid ? result : undefined;
}

/**
 * Processes CSS AST children sequentially to extract mask properties
 *
 * This function handles the complex parsing of CSS mask layer syntax,
 * including position/size combinations separated by "/", various keyword types,
 * and proper ordering according to CSS specifications.
 */
function processCssChildren(children: csstree.CssNode[], result: MaskLayer): boolean {
  let i = 0;
  let hasPositionSize = false;
  let hasUnrecognizedToken = false;

  while (i < children.length) {
    const child = children[i];

    // Skip whitespace and operators (except "/")
    if (child.type === "WhiteSpace") {
      i++;
      continue;
    }

    if (child.type === "Operator" && (child as csstree.Operator).value !== "/") {
      i++;
      continue;
    }

    // Handle mask-image (url(), none, or image functions like gradients)
    if (child.type === "Url" && !result.image) {
      result.image = `url(${(child as csstree.Url).value})`;
      i++;
      continue;
    }

    if (child.type === "Function") {
      const funcNode = child as csstree.FunctionNode;
      if (
        [
          "linear-gradient",
          "radial-gradient",
          "conic-gradient",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeating-conic-gradient",
          "image",
          "image-set",
          "cross-fade",
          "paint",
          "element",
        ].includes(funcNode.name)
      ) {
        if (!result.image) {
          result.image = csstree.generate(child);
        }
        i++;
        continue;
      }
    }

    if (
      child.type === "Identifier" &&
      (child as csstree.Identifier).name === "none" &&
      !result.image
    ) {
      result.image = "none";
      i++;
      continue;
    }

    // Handle position and size (complex parsing needed)
    if (
      !hasPositionSize &&
      ((child.type === "Operator" && (child as csstree.Operator).value === "/") ||
        (child.type === "Identifier" &&
          ["left", "center", "right", "top", "bottom"].includes(
            (child as csstree.Identifier).name
          )) ||
        child.type === "Dimension" ||
        child.type === "Percentage" ||
        child.type === "Number")
    ) {
      const positionParts: string[] = [];
      const sizeParts: string[] = [];
      let _hasSlash = false;

      // Check if we start with "/"
      if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
        _hasSlash = true;
        i++; // skip "/"

        // Collect size parts
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }
          if (
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Identifier" &&
              ["auto", "cover", "contain"].includes((currentChild as csstree.Identifier).name)) ||
            (currentChild.type === "Function" &&
              ["calc", "min", "max", "clamp", "var"].includes(
                (currentChild as csstree.FunctionNode).name
              ))
          ) {
            sizeParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      } else {
        // Collect position parts until we hit "/" or a non-position node
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }

          if (
            currentChild.type === "Operator" &&
            (currentChild as csstree.Operator).value === "/"
          ) {
            _hasSlash = true;
            i++; // skip "/"

            // Collect size parts
            while (i < children.length) {
              const sizeChild = children[i];
              if (sizeChild.type === "WhiteSpace") {
                i++;
                continue;
              }
              if (
                sizeChild.type === "Dimension" ||
                sizeChild.type === "Percentage" ||
                sizeChild.type === "Number" ||
                (sizeChild.type === "Identifier" &&
                  ["auto", "cover", "contain"].includes((sizeChild as csstree.Identifier).name)) ||
                (sizeChild.type === "Function" &&
                  ["calc", "min", "max", "clamp", "var"].includes(
                    (sizeChild as csstree.FunctionNode).name
                  ))
              ) {
                sizeParts.push(csstree.generate(sizeChild));
                i++;
              } else {
                break;
              }
            }
            break;
          } else if (
            (currentChild.type === "Identifier" &&
              ["left", "center", "right", "top", "bottom"].includes(
                (currentChild as csstree.Identifier).name
              )) ||
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Function" &&
              ["calc", "min", "max", "clamp", "var"].includes(
                (currentChild as csstree.FunctionNode).name
              ))
          ) {
            positionParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      }

      if (positionParts.length > 0) {
        result.position = positionParts.join(" ");
      }
      if (sizeParts.length > 0) {
        result.size = sizeParts.join(" ");
      }

      hasPositionSize = true;
      continue;
    }

    // Handle repeat values
    // Note: repeat-x and repeat-y are supported for compatibility with background-repeat,
    // even though the mask-repeat spec technically only allows [repeat|no-repeat|round|space]{1,2}
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(name)) {
        if (!result.repeat) {
          let repeat = name;
          i++;

          // Check for second repeat value
          if (i < children.length && children[i].type === "Identifier") {
            const nextName = (children[i] as csstree.Identifier).name;
            if (
              ["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(nextName)
            ) {
              repeat += ` ${nextName}`;
              i++;
            }
          }

          result.repeat = repeat;
        } else {
          i++;
        }
        continue;
      }
    }

    // Handle mode keywords
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["alpha", "luminance", "match-source"].includes(name)) {
        if (!result.mode) {
          result.mode = name;
        }
        i++;
        continue;
      }
    }

    // Handle composite keywords
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["add", "subtract", "intersect", "exclude"].includes(name)) {
        if (!result.composite) {
          result.composite = name;
        }
        i++;
        continue;
      }
    }

    // Handle geometry-box values (origin/clip)
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (
        ["border-box", "padding-box", "content-box", "fill-box", "stroke-box", "view-box"].includes(
          name
        )
      ) {
        if (!result.origin) {
          result.origin = name;
        } else if (!result.clip) {
          result.clip = name;
        }
        i++;
        continue;
      }
    }

    // Handle "no-clip" keyword for mask-clip
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (name === "no-clip") {
        if (!result.clip) {
          result.clip = "no-clip";
        }
        i++;
        continue;
      }
    }

    // Skip unrecognized nodes - mark as having unrecognized token for stricter error handling
    hasUnrecognizedToken = true;
    i++;
  }

  // Special handling for origin/clip: if a layer specifies only one box value,
  // it applies to both origin and clip
  if (result.origin !== undefined && result.clip === undefined) {
    result.clip = result.origin;
  }

  return !hasUnrecognizedToken;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: MaskLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "mask-image": layers.map((l) => l.image || MASK_DEFAULTS.image),
    "mask-mode": layers.map((l) => l.mode || MASK_DEFAULTS.mode),
    "mask-position": layers.map((l) => l.position || MASK_DEFAULTS.position),
    "mask-size": layers.map((l) => l.size || MASK_DEFAULTS.size),
    "mask-repeat": layers.map((l) => l.repeat || MASK_DEFAULTS.repeat),
    "mask-origin": layers.map((l) => l.origin || MASK_DEFAULTS.origin),
    "mask-clip": layers.map((l) => l.clip || MASK_DEFAULTS.clip),
    "mask-composite": layers.map((l) => l.composite || MASK_DEFAULTS.composite),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/mask.ts ===
// b_path:: src/mask.ts

import { needsAdvancedParser, parseMaskLayers, reconstructLayers } from "./mask-layers";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function mask(value: string): Record<string, string> | undefined {
  // Trim the input value
  const trimmedValue = value.trim();

  // Handle global keywords first
  if (KEYWORD.test(trimmedValue)) {
    return {
      "mask-image": trimmedValue,
      "mask-mode": trimmedValue,
      "mask-position": trimmedValue,
      "mask-size": trimmedValue,
      "mask-repeat": trimmedValue,
      "mask-origin": trimmedValue,
      "mask-clip": trimmedValue,
      "mask-composite": trimmedValue,
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(trimmedValue)) {
    const result = parseMaskLayers(trimmedValue);
    if (result) {
      return reconstructLayers(result.layers);
    }
    return undefined;
  }

  // For single-layer cases, use the advanced parser as well
  // since mask syntax is complex and the parser handles it well
  const result = parseMaskLayers(trimmedValue);
  if (result) {
    return reconstructLayers(result.layers);
  }

  return undefined;
}


=== File: src/normalize-color.ts ===
// b_path:: src/normalize-color.ts
import { hslaRegex, hslRegex, rgbaRegex, rgbRegex } from "./color-utils";

const FUNCTIONS = [hslaRegex(), hslRegex(), rgbRegex(), rgbaRegex()];

export default function normalizeColor(value: string): string {
  return FUNCTIONS.reduce(
    (acc: string, func: RegExp) => acc.replace(func, (match: string) => match.replace(/\s+/g, "")),
    value
  );
}


=== File: src/offset.ts ===
// b_path:: src/offset.ts
import isAngle from "./is-angle.js";
import isLength from "./is-length.js";

function splitTopLevelSlash(input: string): [string, string?] | null {
  let depth = 0;
  let inQuotes = false;
  let quoteChar = "";
  let slashIndex = -1;

  for (let i = 0; i < input.length; i++) {
    const char = input[i];

    if (!inQuotes && (char === '"' || char === "'")) {
      inQuotes = true;
      quoteChar = char;
    } else if (inQuotes && char === quoteChar) {
      inQuotes = false;
      quoteChar = "";
    } else if (!inQuotes) {
      if (char === "(") {
        depth++;
      } else if (char === ")") {
        depth--;
      } else if (char === "/" && depth === 0) {
        if (slashIndex !== -1) {
          // More than one top-level slash
          return null;
        }
        slashIndex = i;
      }
    }
  }

  if (slashIndex === -1) {
    return [input.trim()];
  }

  const main = input.slice(0, slashIndex).trim();
  const anchor = input.slice(slashIndex + 1).trim();
  return [main, anchor];
}

function tokenizeRespectingFunctions(input: string): string[] {
  const tokens: string[] = [];
  let current = "";
  let depth = 0;
  let inQuotes = false;
  let quoteChar = "";

  for (let i = 0; i < input.length; i++) {
    const char = input[i];

    if (!inQuotes && (char === '"' || char === "'")) {
      inQuotes = true;
      quoteChar = char;
      current += char;
    } else if (inQuotes && char === quoteChar) {
      inQuotes = false;
      quoteChar = "";
      current += char;
    } else if (!inQuotes) {
      if (char === "(") {
        depth++;
        current += char;
      } else if (char === ")") {
        depth--;
        current += char;
      } else if (char === " " && depth === 0) {
        if (current.trim()) {
          tokens.push(current.trim());
          current = "";
        }
      } else {
        current += char;
      }
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    tokens.push(current.trim());
  }

  return tokens;
}

function isPositionKeyword(token: string): boolean {
  return /^(auto|normal|left|right|top|bottom|center)$/i.test(token);
}

function parsePosition(tokens: string[]): { position: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  // Two tokens: x y (check first to avoid ambiguity)
  if (tokens.length >= 2) {
    const first = tokens[0];
    const second = tokens[1];
    if (
      (isPositionKeyword(first) || isLength(first)) &&
      (isPositionKeyword(second) || isLength(second))
    ) {
      return { position: `${first} ${second}`, consumed: 2 };
    }
  }

  // auto or normal
  if (tokens[0] === "auto" || tokens[0] === "normal") {
    return { position: tokens[0], consumed: 1 };
  }

  // Single keyword
  if (isPositionKeyword(tokens[0])) {
    return { position: tokens[0], consumed: 1 };
  }

  // Single length/% (horizontal center)
  if (isLength(tokens[0])) {
    return { position: tokens[0], consumed: 1 };
  }

  return null;
}

function parsePath(tokens: string[]): { path: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  const token = tokens[0];

  if (token === "none") {
    return { path: "none", consumed: 1 };
  }

  if (token.startsWith("path(") || token.startsWith("ray(") || token.startsWith("url(")) {
    return { path: token, consumed: 1 };
  }

  return null;
}

function parseDistance(tokens: string[]): { distance: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  if (isLength(tokens[0])) {
    return { distance: tokens[0], consumed: 1 };
  }

  return null;
}

function parseRotate(tokens: string[]): { rotate: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  // Check for compound forms first: auto <angle> or reverse <angle> or <angle> auto/reverse
  if (tokens.length >= 2) {
    const first = tokens[0];
    const second = tokens[1];

    if ((first === "auto" || first === "reverse") && isAngle(second)) {
      return { rotate: `${first} ${second}`, consumed: 2 };
    }
    if (isAngle(first) && (second === "auto" || second === "reverse")) {
      return { rotate: `${second} ${first}`, consumed: 2 };
    }
  }

  // Single tokens
  const token = tokens[0];

  if (token === "auto" || token === "reverse") {
    return { rotate: token, consumed: 1 };
  }

  if (isAngle(token)) {
    return { rotate: token, consumed: 1 };
  }

  return null;
}

function parseAnchor(anchor: string): string | null {
  if (!anchor) return null;

  const tokens = tokenizeRespectingFunctions(anchor);

  if (tokens.length === 1) {
    if (tokens[0] === "auto" || isPositionKeyword(tokens[0])) {
      return tokens[0];
    }
  }

  if (tokens.length === 2) {
    if (
      (isPositionKeyword(tokens[0]) || isLength(tokens[0])) &&
      (isPositionKeyword(tokens[1]) || isLength(tokens[1]))
    ) {
      return `${tokens[0]} ${tokens[1]}`;
    }
  }

  return null;
}

export default (value: string): Record<string, string> | undefined => {
  // Handle global keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "offset-position": value,
      "offset-path": value,
      "offset-distance": value,
      "offset-rotate": value,
      "offset-anchor": value,
    };
  }

  // Split on top-level slash
  const slashSplit = splitTopLevelSlash(value);
  if (!slashSplit) return undefined; // Invalid: multiple slashes

  const [main, anchor] = slashSplit;

  // Tokenize main part
  const tokens = tokenizeRespectingFunctions(main);
  if (tokens.length === 0) return undefined;

  const result: Record<string, string> = {};

  let index = 0;

  // Try to parse position first
  const positionResult = parsePosition(tokens.slice(index));
  if (positionResult) {
    result["offset-position"] = positionResult.position;
    index += positionResult.consumed;
  }

  // Try to parse path
  const pathResult = parsePath(tokens.slice(index));
  if (pathResult) {
    result["offset-path"] = pathResult.path;
    index += pathResult.consumed;
  } else {
    // Path is required unless we have position only
    if (index === 0) return undefined;
  }

  // Try to parse distance
  const distanceResult = parseDistance(tokens.slice(index));
  if (distanceResult) {
    result["offset-distance"] = distanceResult.distance;
    index += distanceResult.consumed;
  }

  // Try to parse rotate
  const rotateResult = parseRotate(tokens.slice(index));
  if (rotateResult) {
    result["offset-rotate"] = rotateResult.rotate;
    index += rotateResult.consumed;
  }

  // Check if all tokens consumed
  if (index !== tokens.length) return undefined;

  // Parse anchor if present
  if (anchor) {
    const parsedAnchor = parseAnchor(anchor);
    if (parsedAnchor === null) return undefined;
    result["offset-anchor"] = parsedAnchor;
  }

  return result;
};


=== File: src/outline.ts ===
// b_path:: src/outline.ts
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function outline(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(values[0])) {
    return {
      "outline-width": values[0],
      "outline-style": values[0],
      "outline-color": values[0],
    };
  }

  const result: Record<string, string> = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (isLength(v) || WIDTH.test(v)) {
      if (result["outline-width"]) return;
      result["outline-width"] = v;
    } else if (STYLE.test(v)) {
      if (result["outline-style"]) return;
      result["outline-style"] = v;
    } else if (isColor(v)) {
      if (result["outline-color"]) return;
      result["outline-color"] = v;
    } else {
      return;
    }
  }

  return result;
}


=== File: src/overflow.ts ===
// b_path:: src/overflow.ts
export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "overflow-x": value,
      "overflow-y": value,
    };
  }

  // Split values on whitespace
  const values = value.trim().split(/\s+/);

  // Validate value count - max 2 values
  if (values.length > 2) {
    return undefined;
  }

  // Valid overflow values
  const validValues = /^(visible|hidden|clip|scroll|auto)$/i;

  // Handle single value - both x and y get the same value
  if (values.length === 1) {
    if (!validValues.test(values[0])) {
      return undefined;
    }
    return {
      "overflow-x": values[0],
      "overflow-y": values[0],
    };
  }

  // Handle two values - first=x, second=y
  if (values.length === 2) {
    if (!validValues.test(values[0]) || !validValues.test(values[1])) {
      return undefined;
    }
    return {
      "overflow-x": values[0],
      "overflow-y": values[1],
    };
  }

  return undefined;
};


=== File: src/place-content.ts ===
// b_path:: src/place-content.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-content": value,
      "justify-content": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Validate processed values
  const validValuePattern =
    /^(normal|space-between|space-around|space-evenly|stretch|center|start|end|flex-start|flex-end|baseline|first baseline|last baseline|safe center|safe start|safe end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe flex-start|unsafe flex-end)$/i;

  for (const val of processedValues) {
    if (!validValuePattern.test(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value
  if (processedValues.length === 1) {
    return {
      "align-content": processedValues[0],
      "justify-content": processedValues[0],
    };
  }

  // Handle two values - first=align-content, second=justify-content
  if (processedValues.length === 2) {
    return {
      "align-content": processedValues[0],
      "justify-content": processedValues[1],
    };
  }

  return undefined;
};


=== File: src/place-items.ts ===
// b_path:: src/place-items.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-items": value,
      "justify-items": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|self-start|self-end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Helper functions for validation
  const isValidAlignItemsValue = (val: string): boolean => {
    return /^(normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  const isValidJustifyItemsValue = (val: string): boolean => {
    return /^(normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|left|right|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  // Validate processed values
  for (const val of processedValues) {
    if (!isValidAlignItemsValue(val) && !isValidJustifyItemsValue(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value, but left/right are invalid for single value
  if (processedValues.length === 1) {
    const val = processedValues[0];
    if (val === "left" || val === "right") {
      return undefined; // Cannot apply left/right to both properties
    }
    if (!isValidAlignItemsValue(val)) {
      return undefined;
    }
    return {
      "align-items": val,
      "justify-items": val,
    };
  }

  // Handle two values - first=align-items, second=justify-items
  if (processedValues.length === 2) {
    const [alignVal, justifyVal] = processedValues;
    if (!isValidAlignItemsValue(alignVal) || alignVal === "left" || alignVal === "right") {
      return undefined; // left/right cannot be used for align-items
    }
    if (!isValidJustifyItemsValue(justifyVal)) {
      return undefined;
    }
    return {
      "align-items": alignVal,
      "justify-items": justifyVal,
    };
  }

  return undefined;
};


=== File: src/place-self.ts ===
// b_path:: src/place-self.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-self": value,
      "justify-self": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|self-start|self-end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Helper functions for validation
  const isValidAlignSelfValue = (val: string): boolean => {
    return /^(auto|normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|anchor-center|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  const isValidJustifySelfValue = (val: string): boolean => {
    return /^(auto|normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|left|right|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  // Validate processed values
  for (const val of processedValues) {
    if (!isValidAlignSelfValue(val) && !isValidJustifySelfValue(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value, but left/right are invalid for single value
  if (processedValues.length === 1) {
    const val = processedValues[0];
    if (val === "left" || val === "right") {
      return undefined; // Cannot apply left/right to both properties
    }
    if (!isValidAlignSelfValue(val)) {
      return undefined;
    }
    return {
      "align-self": val,
      "justify-self": val,
    };
  }

  // Handle two values - first=align-self, second=justify-self
  if (processedValues.length === 2) {
    const [alignVal, justifyVal] = processedValues;
    if (!isValidAlignSelfValue(alignVal) || alignVal === "left" || alignVal === "right") {
      return undefined; // left/right cannot be used for align-self
    }
    if (!isValidJustifySelfValue(justifyVal)) {
      return undefined;
    }
    return {
      "align-self": alignVal,
      "justify-self": justifyVal,
    };
  }

  return undefined;
};


=== File: src/place-utils.ts ===
// b_path:: src/place-utils.ts
export function consolidatePlaceTokens(
  value: string,
  nextTokenPattern: RegExp
): string[] | undefined {
  const tokens = value.trim().split(/\s+/);
  const out: string[] = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (/^(first|last)$/i.test(t) && i + 1 < tokens.length && /^baseline$/i.test(tokens[i + 1])) {
      out.push(`${tokens[i]} ${tokens[i + 1]}`);
      i++;
      continue;
    }
    if (
      /^(safe|unsafe)$/i.test(t) &&
      i + 1 < tokens.length &&
      nextTokenPattern.test(tokens[i + 1])
    ) {
      out.push(`${tokens[i]} ${tokens[i + 1]}`);
      i++;
      continue;
    }
    out.push(t);
  }
  return out.length <= 2 ? out : undefined;
}


=== File: src/schema.ts ===
// b_path:: src/schema.ts
import { z } from "zod";

// Base CSS value schemas
export const CssValueSchema = z.string().describe("CSS property value");
export const CssPropertySchema = z.string().describe("CSS property name");
export const CssDeclarationSchema = z.string().describe("CSS declaration string");

// Format options schema
export const ExpandOptionsSchema = z
  .object({
    format: z.enum(["js", "css"]).default("css").optional().describe("Output format"),
    indent: z.number().min(0).default(0).optional().describe("Indentation for CSS output"),
    separator: z.string().default("\n").optional().describe("Separator between CSS declarations"),
  })
  .describe("Options for CSS expansion");

/**
 * CSS Tree and custom warning types for validation
 */
export const CssTreeSyntaxParseErrorSchema = z
  .object({
    name: z.string(),
    message: z.string(),
    line: z.number(),
    column: z.number(),
    property: z.string().optional(),
    offset: z.number().optional(),
    length: z.number().optional(),
  })
  .describe("CSS Tree syntax parsing error");

export const BStyleWarningSchema = z
  .object({
    property: z.string().describe("CSS property that has the warning"),
    name: z.string().describe("Warning name/type"),
    syntax: z.string().optional().describe("CSS syntax that caused the warning"),
    formattedWarning: z.string().optional().describe("Formatted warning message for display"),
  })
  .describe("Custom warning for CSS property validation");

/**
 * Background layer schema for multi-layer background parsing
 */
export const BackgroundLayerSchema = z
  .object({
    image: z.string().optional().describe("Background image (url, gradient, or none)"),
    position: z.string().optional().describe("Background position (e.g., '10px 20px')"),
    size: z.string().optional().describe("Background size (e.g., 'cover', '100px 200px')"),
    repeat: z.string().optional().describe("Background repeat (e.g., 'no-repeat', 'repeat-x')"),
    attachment: z.string().optional().describe("Background attachment (e.g., 'fixed', 'scroll')"),
    origin: z.string().optional().describe("Background origin (e.g., 'padding-box', 'border-box')"),
    clip: z.string().optional().describe("Background clip (e.g., 'padding-box', 'border-box')"),
  })
  .describe("Single layer in a multi-layer background");

/**
 * Multi-layer background parsing result
 */
export const BackgroundResultSchema = z
  .object({
    layers: z.array(BackgroundLayerSchema).describe("Array of background layers"),
    color: z.string().optional().describe("Global background color applied to all layers"),
  })
  .describe("Result of parsing multi-layer background declaration");

/**
 * Mask layer schema for multi-layer mask parsing
 */
export const MaskLayerSchema = z
  .object({
    image: z.string().optional().describe("Mask image (url, gradient, or none)"),
    mode: z
      .string()
      .optional()
      .describe("Masking mode (e.g., 'alpha', 'luminance', 'match-source')"),
    position: z.string().optional().describe("Mask position (e.g., '10px 20px', 'center')"),
    size: z.string().optional().describe("Mask size (e.g., 'cover', '100px 200px', 'auto')"),
    repeat: z.string().optional().describe("Mask repeat (e.g., 'no-repeat', 'repeat-x')"),
    origin: z
      .string()
      .optional()
      .describe("Mask origin (e.g., 'padding-box', 'border-box', 'content-box')"),
    clip: z
      .string()
      .optional()
      .describe("Mask clip (e.g., 'padding-box', 'border-box', 'content-box', 'no-clip')"),
    composite: z
      .string()
      .optional()
      .describe("Mask composite (e.g., 'add', 'subtract', 'intersect', 'exclude')"),
  })
  .describe("Single layer in a multi-layer mask");

/**
 * Multi-layer mask parsing result
 */
export const MaskResultSchema = z
  .object({
    layers: z.array(MaskLayerSchema).describe("Array of mask layers"),
  })
  .describe("Result of parsing multi-layer mask declaration");

/**
 * Transition layer schema for multi-layer transition parsing
 */
export const TransitionLayerSchema = z
  .object({
    property: z
      .string()
      .optional()
      .describe("Transition property (e.g., 'opacity', 'all', 'transform')"),
    duration: z.string().optional().describe("Transition duration (e.g., '300ms', '0.5s')"),
    timingFunction: z
      .string()
      .optional()
      .describe("Transition timing function (e.g., 'ease', 'cubic-bezier(0.4, 0, 0.2, 1)')"),
    delay: z.string().optional().describe("Transition delay (e.g., '100ms', '0s')"),
  })
  .describe("Single layer in a multi-layer transition");

/**
 * Multi-layer transition parsing result
 */
export const TransitionResultSchema = z
  .object({
    layers: z.array(TransitionLayerSchema).describe("Array of transition layers"),
  })
  .describe("Result of parsing multi-layer transition declaration");

/**
 * Animation layer schema for multi-layer animation parsing
 */
export const AnimationLayerSchema = z
  .object({
    name: z.string().optional().describe("Animation name (e.g., 'spin', 'none')"),
    duration: z.string().optional().describe("Animation duration (e.g., '1s', '300ms')"),
    timingFunction: z
      .string()
      .optional()
      .describe("Animation timing function (e.g., 'ease', 'cubic-bezier(0.4, 0, 0.2, 1)')"),
    delay: z.string().optional().describe("Animation delay (e.g., '100ms', '0s')"),
    iterationCount: z
      .string()
      .optional()
      .describe("Animation iteration count (e.g., '3', 'infinite')"),
    direction: z
      .string()
      .optional()
      .describe(
        "Animation direction (e.g., 'normal', 'reverse', 'alternate', 'alternate-reverse')"
      ),
    fillMode: z
      .string()
      .optional()
      .describe("Animation fill mode (e.g., 'none', 'forwards', 'backwards', 'both')"),
    playState: z.string().optional().describe("Animation play state (e.g., 'running', 'paused')"),
  })
  .describe("Single layer in a multi-layer animation");

/**
 * Multi-layer animation parsing result
 */
export const AnimationResultSchema = z
  .object({
    layers: z.array(AnimationLayerSchema).describe("Array of animation layers"),
  })
  .describe("Result of parsing multi-layer animation declaration");

/**
 * Main expansion result schema
 */
export const ExpandResultSchema = z
  .object({
    ok: z.boolean().describe("Whether expansion was successful (no syntax errors)"),
    result: z
      .union([
        z.record(z.string(), z.string()).describe("JavaScript object format result"),
        z.string().describe("CSS string format result"),
        z
          .array(z.union([z.record(z.string(), z.string()), z.string()]))
          .describe("Array of results for multiple declarations"),
        z.undefined().describe("No result when input is empty or invalid"),
      ])
      .describe("The expanded CSS result"),
    issues: z
      .array(z.union([CssTreeSyntaxParseErrorSchema, BStyleWarningSchema]))
      .describe("Array of syntax errors and validation warnings"),
  })
  .describe("Result of CSS shorthand expansion");

/**
 * Stylesheet validation result schema
 */
export const StylesheetValidationSchema = z
  .object({
    ok: z.boolean().describe("Whether validation passed (no errors)"),
    errors: z.array(CssTreeSyntaxParseErrorSchema).describe("Array of syntax parsing errors"),
    warnings: z.array(BStyleWarningSchema).describe("Array of property validation warnings"),
  })
  .describe("Result of CSS stylesheet validation");

// Derived TypeScript types from schemas
export type ExpandOptions = z.infer<typeof ExpandOptionsSchema>;
export type ExpandResult = z.infer<typeof ExpandResultSchema>;
export type BackgroundLayer = z.infer<typeof BackgroundLayerSchema>;
export type BackgroundResult = z.infer<typeof BackgroundResultSchema>;
export type MaskLayer = z.infer<typeof MaskLayerSchema>;
export type MaskResult = z.infer<typeof MaskResultSchema>;
export type TransitionLayer = z.infer<typeof TransitionLayerSchema>;
export type TransitionResult = z.infer<typeof TransitionResultSchema>;
export type AnimationLayer = z.infer<typeof AnimationLayerSchema>;
export type AnimationResult = z.infer<typeof AnimationResultSchema>;
export type BStyleWarning = z.infer<typeof BStyleWarningSchema>;
export type StylesheetValidation = z.infer<typeof StylesheetValidationSchema>;
export type CssValue = z.infer<typeof CssValueSchema>;
export type CssProperty = z.infer<typeof CssPropertySchema>;
export type CssDeclaration = z.infer<typeof CssDeclarationSchema>;

// Export schemas for runtime validation
export const schemas = {
  ExpandOptions: ExpandOptionsSchema,
  ExpandResult: ExpandResultSchema,
  BackgroundLayer: BackgroundLayerSchema,
  BackgroundResult: BackgroundResultSchema,
  MaskLayer: MaskLayerSchema,
  MaskResult: MaskResultSchema,
  TransitionLayer: TransitionLayerSchema,
  TransitionResult: TransitionResultSchema,
  AnimationLayer: AnimationLayerSchema,
  AnimationResult: AnimationResultSchema,
  BStyleWarning: BStyleWarningSchema,
  StylesheetValidation: StylesheetValidationSchema,
  CssValue: CssValueSchema,
  CssProperty: CssPropertySchema,
  CssDeclaration: CssDeclarationSchema,
} as const;


=== File: src/text-decoration.ts ===
// b_path:: src/text-decoration.ts
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const LINE = /^(none|underline|overline|line-through|blink|spelling-error|grammar-error)$/i;
const STYLE = /^(solid|double|dotted|dashed|wavy)$/i;
const THICKNESS = /^(auto|from-font)$/i;

export default function textDecoration(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return {
      "text-decoration-line": values[0],
      "text-decoration-style": values[0],
      "text-decoration-color": values[0],
      "text-decoration-thickness": values[0],
    };
  }

  const result: Record<string, string> = {};
  const lines: string[] = [];

  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (LINE.test(v)) {
      lines.push(v);
    } else if (STYLE.test(v)) {
      if (result["text-decoration-style"]) return;
      result["text-decoration-style"] = v;
    } else if (isColor(v)) {
      if (result["text-decoration-color"]) return;
      result["text-decoration-color"] = v;
    } else if (THICKNESS.test(v) || isLength(v)) {
      if (result["text-decoration-thickness"]) return;
      result["text-decoration-thickness"] = v;
    } else {
      return;
    }
  }

  if (lines.length > 1 && lines.includes("none")) return;

  if (lines.length > 0) {
    if (lines.length !== new Set(lines).size) return; // Duplicate lines
    result["text-decoration-line"] = lines.join(" ");
  }

  return result;
}


=== File: src/text-emphasis.ts ===
// b_path:: src/text-emphasis.ts
import isColor from "./is-color";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const FILL = /^(filled|open)$/i;
const SHAPE = /^(dot|circle|double-circle|triangle|sesame)$/i;
const STRING_VALUE = /^["'].*["']$/;

export default function textEmphasis(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return {
      "text-emphasis-style": values[0],
      "text-emphasis-color": values[0],
    };
  }

  const result: Record<string, string> = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (v === "none") {
      if (result["text-emphasis-style"]) return;
      result["text-emphasis-style"] = v;
    } else if (STRING_VALUE.test(v)) {
      if (result["text-emphasis-style"]) return;
      result["text-emphasis-style"] = v;
    } else if (FILL.test(v)) {
      if (result["text-emphasis-style"]) return;
      if (i + 1 < values.length && SHAPE.test(values[i + 1])) {
        result["text-emphasis-style"] = `${v} ${values[i + 1]}`;
        i++;
      } else {
        result["text-emphasis-style"] = v;
      }
    } else if (SHAPE.test(v)) {
      if (result["text-emphasis-style"]) return;
      result["text-emphasis-style"] = v;
    } else if (isColor(v)) {
      if (result["text-emphasis-color"]) return;
      result["text-emphasis-color"] = v;
    } else {
      return;
    }
  }

  return result;
}


=== File: src/transition-layers.ts ===
// b_path:: src/transition-layers.ts

import * as csstree from "css-tree";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import type { TransitionLayer, TransitionResult } from "./schema";

// CSS default values for transition properties
export const TRANSITION_DEFAULTS = {
  property: "all",
  duration: "0s",
  timingFunction: "ease",
  delay: "0s",
} as const;

/**
 * Detects if a transition value needs advanced parsing (multi-layer transitions or complex functions)
 */
export function needsAdvancedParser(value: string): boolean {
  // Use advanced parsing for:
  // 1. Multi-layer transitions (comma-separated)
  // 2. Complex timing functions with parentheses
  // Must ignore commas inside parentheses/brackets (functions, rgba(), etc.)
  let parenDepth = 0;
  let bracketDepth = 0;
  let hasFunctions = false;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
      hasFunctions = true;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this indicates multiple layers
      return true;
    }
  }

  // Use advanced parsing for complex timing functions
  return hasFunctions;
}

/**
 * Splits a transition value into layers, respecting nested functions
 */
function splitLayers(value: string): string[] {
  const layers: string[] = [];
  let currentLayer = "";
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this separates layers
      layers.push(currentLayer.trim());
      currentLayer = "";
      continue;
    }

    currentLayer += char;
  }

  // Add the last layer
  if (currentLayer.trim()) {
    layers.push(currentLayer.trim());
  }

  return layers;
}

/**
 * Parses a complex transition value using css-tree AST parsing
 */
export function parseTransitionLayers(value: string): TransitionResult | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer to extract all properties
    const layers: TransitionLayer[] = [];

    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);
      if (!parsedLayer) {
        return undefined; // Parsing failed for this layer
      }
      layers.push(parsedLayer);
    }

    return {
      layers,
    };
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Parses a single transition layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): TransitionLayer | undefined {
  const result: TransitionLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling transition property parsing
  if (!processCssChildren(children, result)) {
    return undefined; // Parsing failed due to invalid syntax
  }

  return result;
}

/**
 * Processes CSS AST children sequentially to extract transition properties
 *
 * This function handles the parsing of CSS transition layer syntax,
 * including property names, time values, and timing functions.
 * CSS ordering rules: first time = duration, second time = delay
 *
 * Returns false if parsing should fail (e.g., too many time values)
 */
function processCssChildren(children: csstree.CssNode[], result: TransitionLayer): boolean {
  let timeCount = 0; // Track first vs second time value

  for (const child of children) {
    // Skip whitespace and operators
    if (child.type === "WhiteSpace" || child.type === "Operator") {
      continue;
    }

    // Handle time values first (duration and delay)
    if (child.type === "Dimension") {
      const timeValue = csstree.generate(child);
      if (isTime(timeValue)) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = timeValue;
        } else {
          result.delay = timeValue;
        }
        timeCount++;
        continue;
      }
    }

    // Handle var() functions as time values
    if (child.type === "Function") {
      const funcValue = csstree.generate(child);
      if (funcValue.startsWith("var(")) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = funcValue;
        } else {
          result.delay = funcValue;
        }
        timeCount++;
        continue;
      }
    }

    // Handle timing functions (keywords and functions)
    if (!result.timingFunction) {
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          result.timingFunction = timingValue;
          continue;
        }
      }

      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          // Fix spacing in function calls (css-tree removes spaces after commas)
          result.timingFunction = funcValue.replace(/,([^\s])/g, ", $1");
          continue;
        }
      }
    }

    // Handle transition-property (none, all, or CSS property names)
    if (child.type === "Identifier" && !result.property) {
      const name = (child as csstree.Identifier).name;
      if (name === "none" || name === "all") {
        result.property = name;
        continue;
      }
      // Check if it looks like a CSS property name (not a timing function)
      // Allow vendor-prefixed properties starting with hyphen
      if (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(name) && !isTimingFunction(name)) {
        result.property = name;
      }
    }
  }

  return true;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: TransitionLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "transition-property": layers.map((l) => l.property || TRANSITION_DEFAULTS.property),
    "transition-duration": layers.map((l) => l.duration || TRANSITION_DEFAULTS.duration),
    "transition-timing-function": layers.map(
      (l) => l.timingFunction || TRANSITION_DEFAULTS.timingFunction
    ),
    "transition-delay": layers.map((l) => l.delay || TRANSITION_DEFAULTS.delay),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/transition.ts ===
// b_path:: src/transition.ts

import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import { needsAdvancedParser, parseTransitionLayers, reconstructLayers } from "./transition-layers";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const PROPERTY_KEYWORD = /^(none|all)$/i;

export default function transition(value: string): Record<string, string> | undefined {
  // Handle global keywords first
  if (KEYWORD.test(value.trim())) {
    return {
      "transition-property": value.trim(),
      "transition-duration": value.trim(),
      "transition-timing-function": value.trim(),
      "transition-delay": value.trim(),
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(value)) {
    const layeredResult = parseTransitionLayers(value);
    if (layeredResult) {
      return reconstructLayers(layeredResult.layers);
    }
    return undefined; // Advanced parsing failed
  }

  // Simple single-layer fallback parser
  const result: Record<string, string> = {};
  const tokens = value.trim().split(/\s+/);
  let timeCount = 0; // Track first vs second time value

  for (const token of tokens) {
    // Handle time values first (duration and delay) - CSS allows flexible ordering
    if (isTime(token) || token.startsWith("var(")) {
      if (timeCount === 0) {
        result["transition-duration"] = token;
      } else if (timeCount === 1) {
        result["transition-delay"] = token;
      } else {
        // More than 2 time values is invalid
        return undefined;
      }
      timeCount++;
      continue;
    }

    // Handle timing functions
    if (!result["transition-timing-function"] && isTimingFunction(token)) {
      result["transition-timing-function"] = token;
      continue;
    }

    // Handle transition-property (none, all, or CSS property names)
    // Only if we haven't set it yet, and it's not a timing function
    if (!result["transition-property"]) {
      if (PROPERTY_KEYWORD.test(token)) {
        result["transition-property"] = token;
        continue;
      }
      // Check if it looks like a CSS property name (not a timing function)
      // Allow vendor-prefixed properties starting with hyphen
      if (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(token) && !isTimingFunction(token)) {
        result["transition-property"] = token;
        continue;
      }
    }

    // If token doesn't match any category, it's invalid
    return undefined;
  }

  // Accept single-token property values - they will expand to defaults

  // Build final result with defaults
  return {
    "transition-property": result["transition-property"] || "all",
    "transition-duration": result["transition-duration"] || "0s",
    "transition-timing-function": result["transition-timing-function"] || "ease",
    "transition-delay": result["transition-delay"] || "0s",
  };
}


=== File: src/validate.ts ===
// b_path:: src/validate.ts
/**
 * Validates CSS stylesheet syntax and property values, providing detailed error formatting.
 *
 * This function parses CSS using the css-tree library and validates each CSS property
 * against the CSS specification. When validation errors are found, it generates
 * formatted error messages with visual context including line numbers, code snippets,
 * and precise error location indicators.
 *
 * @param css - The CSS string to validate
 *
 * @returns StylesheetValidation object containing:
 *   - ok: boolean indicating if validation passed (no errors)
 *   - errors: Array of syntax parsing errors (malformed CSS)
 *   - warnings: Array of property validation errors (invalid property values)
 *
 * @remarks
 * - Context window shows 2 lines around each error for better debugging
 * - Long lines are intelligently truncated with ellipses () for readability
 * - Pointer indicators (^^^) precisely mark the error location and length
 * - Duplicate declarations are automatically deduplicated to avoid redundant warnings
 *
 * @throws Does not throw - parsing errors are captured in the returned errors array
 *
 * @since 1.0.0
 */

import * as csstree from "css-tree";
import {
  type BStyleWarning,
  type StylesheetValidation,
  StylesheetValidationSchema,
} from "./schema";

// Constants
const DEFAULT_MAX_LINE_WIDTH = 80;
const LINE_NUMBER_PADDING = 4;
const CONTEXT_WINDOW_SIZE = 2; // Lines before and after error

export interface BStyleMatchError extends csstree.SyntaxMatchError {
  property: string;
  formattedError?: string;
}

export type { BStyleWarning, StylesheetValidation };

export interface Declaration {
  property: string;
  value: csstree.Value | csstree.Raw;
  node: csstree.CssNode;
}

interface ErrorFormatOptions {
  maxLineWidth: number;
}

interface TruncationBounds {
  startPos: number;
  endPos: number;
  needsStartEllipsis: boolean;
  needsEndEllipsis: boolean;
  availableWidth: number;
}

interface FormattedLine {
  content: string;
  adjustedColumn: number;
}

/**
 * Validates a CSS stylesheet for syntax and property value errors.
 *
 * @param css - The CSS string to validate
 * @returns StylesheetValidation object containing validation results
 */
export function validate(css: string): StylesheetValidation {
  const errors: csstree.SyntaxParseError[] = [];
  const warnings: BStyleMatchError[] = [];
  const declarations: Declaration[] = [];
  const syntax = csstree.lexer;
  const uniqueDecls = new Map<string, number>();

  // Parse CSS
  const ast = csstree.parse(css, {
    context: "declarationList",
    positions: true,
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseCustomProperty: true,
    onParseError(err: csstree.SyntaxParseError) {
      // biome-ignore lint/correctness/noUnusedVariables: remove stack from err
      const { stack, ...rest } = err;
      errors.push(rest);
    },
  });

  // Extract declarations
  csstree.walk(ast, (node) => {
    if (node.type !== "Declaration") {
      return;
    }
    const id = csstree.generate(node);
    if (uniqueDecls.has(id)) {
      uniqueDecls.set(id, uniqueDecls.get(id)! + 1);
      return;
    }
    uniqueDecls.set(id, 1);
    declarations.push({ property: node.property, value: node.value, node });
  });

  // Validate declarations
  // Suppress noisy csstree-match iteration warnings during matching.
  // Control via env var: BStyle_CSSTREE_LOG_LEVEL=ERROR (default) suppresses these messages.
  const suppressNoise = (msg: unknown): boolean => {
    try {
      const s = String(msg);
      return /\[csstree-match\]\s*BREAK after/i.test(s);
    } catch {
      return false;
    }
  };
  const LOG_LEVEL = (process.env.BStyle_CSSTREE_LOG_LEVEL || "ERROR").toUpperCase();
  const QUIET = LOG_LEVEL === "ERROR" || LOG_LEVEL === "SILENT";
  const origWarn = console.warn;
  const origError = console.error;
  try {
    if (QUIET) {
      console.warn = (...args: Parameters<typeof console.warn>) => {
        if (args.length && suppressNoise(args[0])) return;
        return origWarn(...args);
      };
      console.error = (...args: Parameters<typeof console.error>) => {
        if (args.length && suppressNoise(args[0])) return;
        return origError(...args);
      };
    }

    for (const decl of declarations) {
      const match = syntax.matchProperty(decl.property, decl.value);
      const error = match.error as csstree.SyntaxMatchError;

      if (!error) continue;

      // biome-ignore lint/correctness/noUnusedVariables: remove stack from error
      const { stack, name, ...rest } = error;
      warnings.push({
        property: decl.property,
        name,
        ...rest,
      });
    }
  } finally {
    // Always restore console methods
    console.warn = origWarn;
    console.error = origError;
  }

  // Format and display warnings
  const formattedWarnings: BStyleWarning[] = [];

  if (warnings.length > 0) {
    const cssLines = css.split("\n");
    for (const warning of warnings) {
      const formattedError = formatErrorDisplay(cssLines, warning);
      formattedWarnings.push({
        property: warning.property,
        name: warning.name,
        syntax: warning.syntax,
        formattedWarning: `Errors found in: ${warning.property}\n${formattedError.join("\n")}`,
      });
    }
  }

  // Validate and return using Zod schema for type safety
  const result = {
    ok: errors.length === 0,
    errors,
    warnings: formattedWarnings,
  };

  // Validate the result against our Zod schema for runtime type safety
  return StylesheetValidationSchema.parse(result);
}

export function validateDeclaration(value: string, prop: string): StylesheetValidation {
  const css = `.class {${prop}: ${value};}`;
  const result = validate(css);
  return result;
}

// Helper functions
function calculateLineWindow(
  errorLine: number,
  totalLines: number
): { start: number; end: number } {
  const start = Math.max(1, errorLine - CONTEXT_WINDOW_SIZE);
  const end = Math.min(totalLines, errorLine + CONTEXT_WINDOW_SIZE);
  return { start, end };
}

function formatLineNumber(lineNum: number, maxLineNum: number): string {
  const maxDigits = Math.max(maxLineNum.toString().length, 1);
  const paddedNum = lineNum.toString().padStart(maxDigits, " ");
  const prefix = " ".repeat(LINE_NUMBER_PADDING - maxDigits);
  return `${prefix}${paddedNum} |`;
}

function trimLine(line: string): { trimmed: string; spacesRemoved: number } {
  const trimmed = line.trimStart();
  const spacesRemoved = line.length - trimmed.length;
  return { trimmed, spacesRemoved };
}

function calculateTruncationBounds(
  lineLength: number,
  errorColumn: number,
  maxWidth: number
): TruncationBounds {
  if (lineLength <= maxWidth) {
    return {
      startPos: 0,
      endPos: lineLength,
      needsStartEllipsis: false,
      needsEndEllipsis: false,
      availableWidth: maxWidth,
    };
  }

  // Reserve space for potential ellipses
  let availableWidth = maxWidth - 2;
  const halfWidth = Math.floor(availableWidth / 2);
  let startPos = Math.max(0, errorColumn - halfWidth - 1);

  // Determine if we need start ellipsis
  const needsStartEllipsis = startPos > 0;

  if (!needsStartEllipsis) {
    // No start truncation - reclaim space for end-only ellipsis
    availableWidth = maxWidth - 1;
  } else {
    // Skip one additional character for better spacing after ellipsis
    startPos = startPos + 1;
  }

  let endPos = startPos + availableWidth;
  let needsEndEllipsis = endPos < lineLength;

  // Adjust if we hit the end of the line
  if (endPos >= lineLength) {
    endPos = lineLength;
    needsEndEllipsis = false;

    if (needsStartEllipsis) {
      startPos = Math.max(0, endPos - availableWidth);
    }
  }

  return {
    startPos,
    endPos,
    needsStartEllipsis,
    needsEndEllipsis,
    availableWidth,
  };
}

function applyTruncation(
  line: string,
  bounds: TruncationBounds,
  originalErrorColumn: number
): FormattedLine {
  let content = line.slice(bounds.startPos, bounds.endPos);
  let adjustedColumn = originalErrorColumn - bounds.startPos;

  if (bounds.needsStartEllipsis) {
    content = `${content}`;
    adjustedColumn = adjustedColumn + 1;
  }

  if (bounds.needsEndEllipsis) {
    content = `${content}`;
  }

  return { content, adjustedColumn };
}

function formatContextLine(line: string, maxWidth: number): string {
  const { trimmed } = trimLine(line);

  if (trimmed.length <= maxWidth) {
    return trimmed;
  }

  return `${trimmed.slice(0, maxWidth - 1)}`;
}

function formatErrorLine(line: string, errorColumn: number, maxWidth: number): FormattedLine {
  // Input validation
  if (errorColumn < 1) {
    throw new Error("Error column must be >= 1");
  }

  const { trimmed, spacesRemoved } = trimLine(line);
  const adjustedErrorColumn = Math.max(1, errorColumn - spacesRemoved);

  // Handle case where line fits without truncation after trimming
  if (trimmed.length <= maxWidth) {
    return {
      content: trimmed,
      adjustedColumn: adjustedErrorColumn,
    };
  }

  // Calculate truncation bounds using the original error column position
  const bounds = calculateTruncationBounds(line.length, errorColumn, maxWidth);

  // Special handling for start-of-line case (after trimming consideration)
  if (bounds.startPos === 0 || bounds.startPos <= spacesRemoved) {
    // Use trimmed line for start-of-line truncation
    const trimmedBounds = calculateTruncationBounds(trimmed.length, adjustedErrorColumn, maxWidth);
    return applyTruncation(trimmed, trimmedBounds, adjustedErrorColumn);
  }

  // Standard middle-of-line truncation
  return applyTruncation(line, bounds, errorColumn);
}

function createPointerLine(prefixLength: number, column: number, length: number): string {
  const safeLength = Math.max(1, length ?? 1);
  const safeColumn = Math.max(1, column);

  const pointerPrefix = " ".repeat(prefixLength);
  const dashes = "-".repeat(safeColumn - 1);
  const carets = "^".repeat(safeLength);

  return pointerPrefix + dashes + carets;
}

function formatErrorDisplay(
  cssLines: string[],
  warning: BStyleMatchError,
  options: ErrorFormatOptions = { maxLineWidth: DEFAULT_MAX_LINE_WIDTH }
): string[] {
  // Input validation
  if (!cssLines.length || warning.line < 1 || warning.line > cssLines.length) {
    return [`Invalid error location: line ${warning.line}`];
  }
  const errorLine = warning.line;
  const errorColumn = warning.column;
  const mismatchLength = warning.mismatchLength ?? 1;

  const { start, end } = calculateLineWindow(errorLine, cssLines.length);
  const maxLineNum = end;
  const linePrefix = formatLineNumber(1, maxLineNum);
  const prefixLength = linePrefix.length;
  const availableWidth = options.maxLineWidth - prefixLength;

  const result: string[] = [];

  for (let lineNum = start; lineNum <= end; lineNum++) {
    const lineIndex = lineNum - 1;
    const currentLine = cssLines[lineIndex] ?? "";
    const currentPrefix = formatLineNumber(lineNum, maxLineNum);

    if (lineNum === errorLine) {
      // Format error line
      const { content, adjustedColumn } = formatErrorLine(currentLine, errorColumn, availableWidth);

      result.push(currentPrefix + content);

      // Add pointer line
      const pointerLine = createPointerLine(prefixLength, adjustedColumn, mismatchLength);
      result.push(pointerLine);
    } else {
      // Format context line
      const formattedLine = formatContextLine(currentLine, availableWidth);
      result.push(currentPrefix + formattedLine);
    }
  }

  return result;
}


