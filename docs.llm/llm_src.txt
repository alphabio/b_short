Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */.venv/* -not -path */.next/* -not -path */venv/* -not -path */node_modules/* -not -path */build/* -not -path */dist/* -not -path */.git/* -not -path */.idea/* -not -path */.vscode/*
=== File: src/animation-layers.ts ===
// b_path:: src/animation-layers.ts

import * as csstree from "css-tree";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import { hasTopLevelCommas, parseLayersGeneric } from "./layer-parser-utils";
import type { AnimationLayer, AnimationResult } from "./schema";

// CSS default values for animation properties
export const ANIMATION_DEFAULTS = {
  name: "none",
  duration: "0s",
  timingFunction: "ease",
  delay: "0s",
  iterationCount: "1",
  direction: "normal",
  fillMode: "none",
  playState: "running",
} as const;

/**
 * Detects if an animation value needs advanced parsing (multi-layer animations or complex functions)
 */
export function needsAdvancedParser(value: string): boolean {
  return hasTopLevelCommas(value, true);
}

/**
 * Parses a complex animation value using css-tree AST parsing
 */
export function parseAnimationLayers(value: string): AnimationResult | undefined {
  const layers = parseLayersGeneric(value, parseSingleLayer);
  return layers ? { layers } : undefined;
}

/**
 * Parses a single animation layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): AnimationLayer | undefined {
  const result: AnimationLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling animation property parsing
  if (!processCssChildren(children, result)) {
    return undefined; // Parsing failed due to invalid syntax
  }

  return result;
}

/**
 * Processes CSS AST children sequentially to extract animation properties
 *
 * This function handles the parsing of CSS animation layer syntax,
 * including animation names, time values, timing functions, iteration counts,
 * direction, fill mode, and play state.
 * CSS ordering rules: first time = duration, second time = delay
 *
 * Returns false if parsing should fail (e.g., too many time values, unrecognized tokens, duplicates)
 */
function processCssChildren(children: csstree.CssNode[], result: AnimationLayer): boolean {
  let timeCount = 0; // Track first vs second time value

  for (const child of children) {
    let matched = false; // Track if this token was recognized

    // Skip whitespace and operators
    if (child.type === "WhiteSpace" || child.type === "Operator") {
      continue;
    }

    // Handle animation name first (can be any identifier including var() or quoted strings)
    if (!result.name) {
      if (child.type === "Identifier") {
        const name = (child as csstree.Identifier).name;
        if (name === "none") {
          result.name = "none";
          matched = true;
        }
        // Check if it looks like a valid animation name identifier
        // Allow custom identifiers matching pattern, but exclude timing functions and other keywords
        else if (
          /^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(name) &&
          !isTimingFunction(name) &&
          !/^(normal|reverse|alternate|alternate-reverse|none|forwards|backwards|both|running|paused|infinite)$/i.test(
            name
          )
        ) {
          result.name = name;
          matched = true;
        }
      } else if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (funcValue.startsWith("var(")) {
          result.name = funcValue;
          matched = true;
        }
      } else if (child.type === "String") {
        result.name = csstree.generate(child);
        matched = true;
      }

      if (matched) continue;
    }

    // Handle time values (duration and delay)
    if (child.type === "Dimension") {
      const timeValue = csstree.generate(child);
      if (isTime(timeValue)) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = timeValue;
        } else {
          result.delay = timeValue;
        }
        timeCount++;
        matched = true;
      }
    }

    // Handle var() functions as time values
    if (child.type === "Function") {
      const funcValue = csstree.generate(child);
      if (funcValue.startsWith("var(")) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = funcValue;
        } else {
          result.delay = funcValue;
        }
        timeCount++;
        matched = true;
      }
    }

    // Handle timing functions (keywords and functions)
    if (!result.timingFunction) {
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          result.timingFunction = timingValue;
          matched = true;
        }
      }

      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          // Fix spacing in function calls (css-tree removes spaces after commas)
          result.timingFunction = funcValue.replace(/,([^\s])/g, ", $1");
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          return false; // Duplicate timing function
        }
      }
      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          return false; // Duplicate timing function
        }
      }
    }

    // Handle iteration count
    if (!result.iterationCount) {
      if (child.type === "Number") {
        const numValue = csstree.generate(child);
        result.iterationCount = numValue;
        matched = true;
      }
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (identValue === "infinite") {
          result.iterationCount = "infinite";
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Number") {
        return false; // Duplicate iteration count
      }
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (identValue === "infinite") {
          return false; // Duplicate iteration count
        }
      }
    }

    // Handle direction keywords
    if (!result.direction) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(normal|reverse|alternate|alternate-reverse)$/i.test(identValue)) {
          result.direction = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(normal|reverse|alternate|alternate-reverse)$/i.test(identValue)) {
          return false; // Duplicate direction
        }
      }
    }

    // Handle fill mode keywords
    if (!result.fillMode) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(none|forwards|backwards|both)$/i.test(identValue)) {
          result.fillMode = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(none|forwards|backwards|both)$/i.test(identValue)) {
          return false; // Duplicate fill mode
        }
      }
    }

    // Handle play state keywords
    if (!result.playState) {
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(running|paused)$/i.test(identValue)) {
          result.playState = identValue;
          matched = true;
        }
      }
    } else {
      // Check for duplicates
      if (child.type === "Identifier") {
        const identValue = csstree.generate(child);
        if (/^(running|paused)$/i.test(identValue)) {
          return false; // Duplicate play state
        }
      }
    }

    // If token was not matched by any category, it's unrecognized
    if (!matched) {
      return false;
    }
  }

  return true;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: AnimationLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "animation-name": layers.map((l) => l.name || ANIMATION_DEFAULTS.name),
    "animation-duration": layers.map((l) => l.duration || ANIMATION_DEFAULTS.duration),
    "animation-timing-function": layers.map(
      (l) => l.timingFunction || ANIMATION_DEFAULTS.timingFunction
    ),
    "animation-delay": layers.map((l) => l.delay || ANIMATION_DEFAULTS.delay),
    "animation-iteration-count": layers.map(
      (l) => l.iterationCount || ANIMATION_DEFAULTS.iterationCount
    ),
    "animation-direction": layers.map((l) => l.direction || ANIMATION_DEFAULTS.direction),
    "animation-fill-mode": layers.map((l) => l.fillMode || ANIMATION_DEFAULTS.fillMode),
    "animation-play-state": layers.map((l) => l.playState || ANIMATION_DEFAULTS.playState),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/animation.ts ===
// b_path:: src/animation.ts

import {
  ANIMATION_DEFAULTS,
  needsAdvancedParser,
  parseAnimationLayers,
  reconstructLayers,
} from "./animation-layers";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const ITERATION_COUNT = /^(infinite|[0-9]+(\.[0-9]+)?)$/;
const DIRECTION = /^(normal|reverse|alternate|alternate-reverse)$/i;
const FILL_MODE = /^(none|forwards|backwards|both)$/i;
const PLAY_STATE = /^(running|paused)$/i;

export default function animation(value: string): Record<string, string> | undefined {
  // Handle global keywords first
  if (KEYWORD.test(value.trim())) {
    return {
      "animation-name": value.trim(),
      "animation-duration": value.trim(),
      "animation-timing-function": value.trim(),
      "animation-delay": value.trim(),
      "animation-iteration-count": value.trim(),
      "animation-direction": value.trim(),
      "animation-fill-mode": value.trim(),
      "animation-play-state": value.trim(),
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(value)) {
    const layeredResult = parseAnimationLayers(value);
    if (layeredResult) {
      return reconstructLayers(layeredResult.layers);
    }
    return undefined; // Advanced parsing failed
  }

  // Simple single-layer fallback parser
  const result: Record<string, string> = {};
  const tokens = value.trim().split(/\s+/);
  let timeCount = 0; // Track first vs second time value

  for (const token of tokens) {
    // Handle animation name first (can be any identifier including var() or quoted strings)
    if (!result["animation-name"]) {
      if (token === "none") {
        result["animation-name"] = "none";
        continue;
      }
      // Check if it looks like a valid animation name identifier
      // Allow custom identifiers matching pattern, var() functions, quoted strings, but exclude timing functions and other keywords
      if (
        (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(token) ||
          token.startsWith("var(") ||
          (token.startsWith('"') && token.endsWith('"')) ||
          (token.startsWith("'") && token.endsWith("'"))) &&
        !isTimingFunction(token) &&
        !DIRECTION.test(token) &&
        !FILL_MODE.test(token) &&
        !PLAY_STATE.test(token) &&
        !ITERATION_COUNT.test(token)
      ) {
        result["animation-name"] = token;
        continue;
      }
    }

    // Handle time values (duration and delay) - CSS allows flexible ordering
    if (isTime(token)) {
      if (timeCount === 0) {
        result["animation-duration"] = token;
      } else if (timeCount === 1) {
        result["animation-delay"] = token;
      } else {
        // More than 2 time values is invalid
        return undefined;
      }
      timeCount++;
      continue;
    }

    // Handle timing functions
    if (!result["animation-timing-function"] && isTimingFunction(token)) {
      result["animation-timing-function"] = token;
      continue;
    }

    // Handle iteration count
    if (!result["animation-iteration-count"] && ITERATION_COUNT.test(token)) {
      result["animation-iteration-count"] = token;
      continue;
    }

    // Handle direction keywords
    if (!result["animation-direction"] && DIRECTION.test(token)) {
      result["animation-direction"] = token;
      continue;
    }

    // Handle fill mode keywords
    if (!result["animation-fill-mode"] && FILL_MODE.test(token)) {
      result["animation-fill-mode"] = token;
      continue;
    }

    // Handle play state keywords
    if (!result["animation-play-state"] && PLAY_STATE.test(token)) {
      result["animation-play-state"] = token;
      continue;
    }

    // If token doesn't match any category, it's invalid
    return undefined;
  }

  // Accept single-token property values - they will expand to defaults

  // Build final result with defaults
  return {
    "animation-name": result["animation-name"] || ANIMATION_DEFAULTS.name,
    "animation-duration": result["animation-duration"] || ANIMATION_DEFAULTS.duration,
    "animation-timing-function":
      result["animation-timing-function"] || ANIMATION_DEFAULTS.timingFunction,
    "animation-delay": result["animation-delay"] || ANIMATION_DEFAULTS.delay,
    "animation-iteration-count":
      result["animation-iteration-count"] || ANIMATION_DEFAULTS.iterationCount,
    "animation-direction": result["animation-direction"] || ANIMATION_DEFAULTS.direction,
    "animation-fill-mode": result["animation-fill-mode"] || ANIMATION_DEFAULTS.fillMode,
    "animation-play-state": result["animation-play-state"] || ANIMATION_DEFAULTS.playState,
  };
}


=== File: src/background-layers.ts ===
// b_path:: src/background-layers.ts

import * as csstree from "css-tree";
import isColor from "./is-color";
import { hasTopLevelCommas, splitLayers } from "./layer-parser-utils";
import type { BackgroundLayer, BackgroundResult } from "./schema";

// CSS default values for background properties
export const BACKGROUND_DEFAULTS = {
  image: "none",
  position: "0% 0%",
  size: "auto auto",
  repeat: "repeat",
  attachment: "scroll",
  origin: "padding-box",
  clip: "border-box",
} as const;

/**
 * Detects if a background value needs advanced parsing (multi-layer backgrounds)
 */
export function needsAdvancedParser(value: string): boolean {
  return hasTopLevelCommas(value);
}

/**
 * Parses a complex background value using css-tree AST parsing
 */
export function parseBackgroundLayers(value: string): BackgroundResult | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer to extract all properties
    const parsedLayers: Array<BackgroundLayer & { color?: string }> = [];
    let globalColor: string | undefined;

    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);

      // Extract color from the last layer that has one
      if (parsedLayer.color) {
        globalColor = parsedLayer.color;
      }

      parsedLayers.push(parsedLayer);
    }

    // Now distribute properties across layers according to CSS rules
    const layers = distributeLayerProperties(parsedLayers);

    return {
      layers,
      color: globalColor,
    };
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Distributes properties across layers according to CSS background rules
 */
function distributeLayerProperties(
  parsedLayers: Array<BackgroundLayer & { color?: string }>
): BackgroundLayer[] {
  // For CSS backgrounds, properties are NOT distributed across layers.
  // Each layer only gets the properties that were explicitly specified for it.
  // Unspecified properties remain undefined and get default values during reconstruction.

  const result: BackgroundLayer[] = [];

  // Just copy the parsed properties - no distribution needed
  for (const layer of parsedLayers) {
    const { color: _, ...layerProps } = layer;
    result.push(layerProps);
  }

  // Special handling for origin/clip: if a layer specifies only one box value,
  // it applies to both origin and clip
  result.forEach((layer) => {
    if (layer.origin !== undefined && layer.clip === undefined) {
      layer.clip = layer.origin;
    }
  });

  return result;
}

/**
 * Parses a single background layer using css-tree AST parsing
 */
function parseSingleLayerWithCssTree(layerValue: string): BackgroundLayer & { color?: string } {
  const result: BackgroundLayer & { color?: string } = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling position/size parsing
  processCssChildren(children, result);

  return result;
}

/**
 * Processes CSS AST children sequentially to extract background properties
 *
 * This function handles the complex parsing of CSS background layer syntax,
 * including position/size combinations separated by "/", various keyword types,
 * and proper ordering according to CSS specifications.
 */
function processCssChildren(
  children: csstree.CssNode[],
  result: BackgroundLayer & { color?: string }
): void {
  let i = 0;
  let hasPositionSize = false;

  while (i < children.length) {
    const child = children[i];

    // Skip whitespace and operators (except "/")
    if (child.type === "WhiteSpace") {
      i++;
      continue;
    }

    if (child.type === "Operator" && (child as csstree.Operator).value !== "/") {
      i++;
      continue;
    }

    // Handle background-image (url(), none, or image functions like gradients)
    if (child.type === "Url" && !result.image) {
      result.image = `url(${(child as csstree.Url).value})`;
      i++;
      continue;
    }

    if (child.type === "Function") {
      const funcNode = child as csstree.FunctionNode;
      if (
        [
          "linear-gradient",
          "radial-gradient",
          "conic-gradient",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeating-conic-gradient",
          "image",
          "element",
        ].includes(funcNode.name)
      ) {
        if (!result.image) {
          result.image = csstree.generate(child);
        }
        i++;
        continue;
      }
    }

    if (
      child.type === "Identifier" &&
      (child as csstree.Identifier).name === "none" &&
      !result.image
    ) {
      result.image = "none";
      i++;
      continue;
    }

    // Handle position and size (complex parsing needed)
    if (
      !hasPositionSize &&
      ((child.type === "Operator" && (child as csstree.Operator).value === "/") ||
        (child.type === "Identifier" &&
          ["left", "center", "right", "top", "bottom"].includes(
            (child as csstree.Identifier).name
          )) ||
        child.type === "Dimension" ||
        child.type === "Percentage" ||
        child.type === "Number")
    ) {
      const positionParts: string[] = [];
      const sizeParts: string[] = [];
      let _hasSlash = false;

      // Check if we start with "/"
      if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
        _hasSlash = true;
        i++; // skip "/"

        // Collect size parts
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }
          if (
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Identifier" &&
              ["auto", "cover", "contain"].includes((currentChild as csstree.Identifier).name))
          ) {
            sizeParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      } else {
        // Collect position parts until we hit "/" or a non-position node
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }

          if (
            currentChild.type === "Operator" &&
            (currentChild as csstree.Operator).value === "/"
          ) {
            _hasSlash = true;
            i++; // skip "/"

            // Collect size parts
            while (i < children.length) {
              const sizeChild = children[i];
              if (sizeChild.type === "WhiteSpace") {
                i++;
                continue;
              }
              if (
                sizeChild.type === "Dimension" ||
                sizeChild.type === "Percentage" ||
                sizeChild.type === "Number" ||
                (sizeChild.type === "Identifier" &&
                  ["auto", "cover", "contain"].includes((sizeChild as csstree.Identifier).name))
              ) {
                sizeParts.push(csstree.generate(sizeChild));
                i++;
              } else {
                break;
              }
            }
            break;
          } else if (
            (currentChild.type === "Identifier" &&
              ["left", "center", "right", "top", "bottom"].includes(
                (currentChild as csstree.Identifier).name
              )) ||
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number"
          ) {
            positionParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      }

      if (positionParts.length > 0) {
        result.position = positionParts.join(" ");
      }
      if (sizeParts.length > 0) {
        result.size = sizeParts.join(" ");
      }

      hasPositionSize = true;
      continue;
    }

    // Handle repeat values
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(name)) {
        if (!result.repeat) {
          let repeat = name;
          i++;

          // Check for second repeat value
          if (i < children.length && children[i].type === "Identifier") {
            const nextName = (children[i] as csstree.Identifier).name;
            if (
              ["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(nextName)
            ) {
              repeat += ` ${nextName}`;
              i++;
            }
          }

          result.repeat = repeat;
        } else {
          i++;
        }
        continue;
      }
    }

    // Handle attachment
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["fixed", "local", "scroll"].includes(name)) {
        if (!result.attachment) {
          result.attachment = name;
        }
        i++;
        continue;
      }
    }

    // Handle box values (origin/clip)
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["border-box", "padding-box", "content-box"].includes(name)) {
        if (!result.origin) {
          result.origin = name;
        } else if (!result.clip) {
          result.clip = name;
        }
        i++;
        continue;
      }
    }

    // Handle colors
    if (child.type === "Identifier" || child.type === "Function" || child.type === "Hash") {
      const value = csstree.generate(child);
      if (isColor(value)) {
        result.color = value;
        i++;
        continue;
      }
    }

    // Skip unrecognized nodes
    i++;
  }
}

/**
 * Parses a single background layer using css-tree AST parsing
 *
 * This function now uses css-tree for robust CSS parsing instead of
 * the previous custom tokenizer approach.
 */
function parseSingleLayer(layerValue: string): BackgroundLayer & { color?: string } {
  return parseSingleLayerWithCssTree(layerValue);
}

/**
 * Distributes property values across layers according to CSS rules
 */
export function distributeProperties(
  layers: BackgroundLayer[],
  properties: Record<string, string[]>
): BackgroundLayer[] {
  const result = layers.map((layer) => ({ ...layer }));

  // Apply property distribution for each property type
  Object.entries(properties).forEach(([property, values]) => {
    const distributedValues = distributeValues(values, layers.length);

    distributedValues.forEach((value, index) => {
      if (result[index]) {
        (result[index] as BackgroundLayer)[property as keyof BackgroundLayer] = value;
      }
    });
  });

  return result;
}

/**
 * Distributes values across layers using CSS repetition rules
 */
export function distributeValues(values: string[], layerCount: number): string[] {
  if (values.length === 0) return [];

  const result: string[] = [];

  for (let i = 0; i < layerCount; i++) {
    // CSS rule: repeat values cyclically if fewer than layers
    result.push(values[i % values.length]);
  }

  return result;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(
  layers: BackgroundLayer[],
  color?: string
): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "background-image": layers.map((l) => l.image || BACKGROUND_DEFAULTS.image),
    "background-position": layers.map((l) => l.position || BACKGROUND_DEFAULTS.position),
    "background-size": layers.map((l) => l.size || BACKGROUND_DEFAULTS.size),
    "background-repeat": layers.map((l) => l.repeat || BACKGROUND_DEFAULTS.repeat),
    "background-attachment": layers.map((l) => l.attachment || BACKGROUND_DEFAULTS.attachment),
    "background-origin": layers.map((l) => l.origin || BACKGROUND_DEFAULTS.origin),
    "background-clip": layers.map((l) => l.clip || BACKGROUND_DEFAULTS.clip),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  // Add color (defaults to transparent if not specified)
  result["background-color"] = color || "transparent";

  return result;
}


=== File: src/background.ts ===
// b_path:: src/background.ts

import { parseBackgroundLayers, reconstructLayers } from "./background-layers";
import { cssUrlRegex } from "./color-utils";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const ATTACHMENT = /^(fixed|local|scroll)$/;
const BOX = /^(border-box|padding-box|content-box)$/;
const IMAGE = new RegExp(`^(none|${cssUrlRegex().source})$`, "i");
const REPEAT_SINGLE = /^(repeat-x|repeat-y)$/i;
const REPEAT_DOUBLE = /^(repeat|space|round|no-repeat)$/i;
const POSITION_HORIZONTAL = /^(left|center|right)$/;
const POSITION_VERTICAL = /^(top|center|bottom)$/;
const SIZE_SINGLE = /^(cover|contain)$/;
const KEYWORD = /^(inherit|initial)$/i;

interface BackgroundResult {
  attachment?: string;
  clip?: string;
  image?: string;
  repeat?: string;
  color?: string;
  position?: string;
  size?: string;
}

const normalizeUrl = (value: string): string =>
  value.replace(cssUrlRegex(), (match: string) =>
    match.replace(/^url\(\s+/, "url(").replace(/\s+\)$/, ")")
  );

export default function background(value: string): Record<string, string> | undefined {
  // Use advanced parsing for all cases - it handles both simple and complex syntax better
  const layeredResult = parseBackgroundLayers(value);
  if (layeredResult) {
    return reconstructLayers(layeredResult.layers, layeredResult.color);
  }

  // Fallback to simple parsing if advanced parsing fails
  return simpleBackgroundParser(value);
}

function simpleBackgroundParser(value: string): Record<string, string> | undefined {
  // Use existing single-layer parsing logic as fallback
  const result: BackgroundResult = {};
  const values = normalizeUrl(normalizeColor(value))
    .replace(/\(.*\/.*\)|(\/)+/g, (match: string, group1: string) => (!group1 ? match : " / "))
    .split(/\s+/);

  const first = values[0];

  if (values.length === 1 && KEYWORD.test(first)) {
    return {
      "background-attachment": first,
      "background-clip": first,
      "background-image": first,
      "background-repeat": first,
      "background-color": first,
      "background-position": first,
      "background-size": first,
    };
  }

  for (let i = 0; i < values.length; i++) {
    let v = values[i];

    if (ATTACHMENT.test(v)) {
      if (result.attachment) return;
      result.attachment = v;
    } else if (BOX.test(v)) {
      if (result.clip) return;
      result.clip = v;
    } else if (IMAGE.test(v)) {
      if (result.image) return;
      result.image = v;
    } else if (REPEAT_SINGLE.test(v)) {
      if (result.repeat) return;
      result.repeat = v;
    } else if (REPEAT_DOUBLE.test(v)) {
      if (result.repeat) return;

      const n = values[i + 1];

      if (n && REPEAT_DOUBLE.test(n)) {
        v += ` ${n}`;
        i++;
      }

      result.repeat = v;
    } else if (isColor(v)) {
      if (result.color) return;
      result.color = v;
    } else if (POSITION_HORIZONTAL.test(v) || POSITION_VERTICAL.test(v) || isLength(v)) {
      if (result.position) return;

      const n = values[i + 1];
      const isHorizontal = POSITION_HORIZONTAL.test(v) || isLength(v);
      const isVertical = n && (POSITION_VERTICAL.test(n) || isLength(n));

      if (isHorizontal && isVertical) {
        result.position = `${v} ${n}`;
        i++;
      } else {
        result.position = v;
      }

      const nextV = values[i + 1];

      if (nextV === "/") {
        i += 2;
        const sizeV = values[i];

        if (SIZE_SINGLE.test(sizeV)) {
          result.size = sizeV;
        } else if (sizeV === "auto" || isLength(sizeV)) {
          let sizeValue = sizeV;
          const sizeN = values[i + 1];

          if (sizeN === "auto" || isLength(sizeN)) {
            sizeValue += ` ${sizeN}`;
            i++;
          }

          result.size = sizeValue;
        } else {
          return;
        }
      }
    } else {
      return;
    }
  }

  const finalResult: Record<string, string> = {};
  for (const key in result) {
    if (result[key as keyof BackgroundResult]) {
      finalResult[`background-${key}`] = result[key as keyof BackgroundResult] as string;
    }
  }
  return finalResult;
}


=== File: src/border-radius.ts ===
// b_path:: src/border-radius.ts

/**
 * Expand 1-4 values following CSS box model (top-left, top-right, bottom-right, bottom-left)
 */
const expandFourValues = (values: string[]): string[] => {
  if (values.length === 1) return [values[0], values[0], values[0], values[0]];
  if (values.length === 2) return [values[0], values[1], values[0], values[1]];
  if (values.length === 3) return [values[0], values[1], values[2], values[1]];
  if (values.length === 4) return values;
  return []; // Invalid
};

const borderRadius = (value: string): Record<string, string> | undefined => {
  // Check if there's a slash separator for horizontal/vertical radii
  const slashIndex = value.indexOf("/");

  if (slashIndex !== -1) {
    // Split horizontal and vertical radii
    const horizontalPart = value.slice(0, slashIndex).trim();
    const verticalPart = value.slice(slashIndex + 1).trim();

    const horizontalValues = horizontalPart.split(/\s+/).filter((v) => v);
    const verticalValues = verticalPart.split(/\s+/).filter((v) => v);

    // Expand both sets to 4 values
    const horizontal = expandFourValues(horizontalValues);
    const vertical = expandFourValues(verticalValues);

    if (horizontal.length === 0 || vertical.length === 0) return;

    // Combine into corner-specific values
    const corners = ["top-left", "top-right", "bottom-right", "bottom-left"];
    const result: Record<string, string> = {};

    for (let i = 0; i < 4; i++) {
      result[`border-${corners[i]}-radius`] = `${horizontal[i]} ${vertical[i]}`;
    }

    return result;
  }

  // No slash - simple case with uniform horizontal and vertical radii
  const values = value.split(/\s+/).filter((v) => v);
  const expanded = expandFourValues(values);

  if (expanded.length === 0) return;

  const corners = ["top-left", "top-right", "bottom-right", "bottom-left"];
  const result: Record<string, string> = {};

  for (let i = 0; i < 4; i++) {
    result[`border-${corners[i]}-radius`] = expanded[i];
  }

  return result;
};

export default borderRadius;


=== File: src/border.ts ===
// b_path:: src/border.ts
import directional from "./directional";
import { sortProperties } from "./index";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

interface BorderProperties {
  width?: string;
  style?: string;
  color?: string;
}

interface BorderResult extends BorderProperties {
  boxSizing?: string;
}

type BorderFunction = {
  (value: string): Record<string, string> | undefined;
  width: (value: string) => Record<string, string> | undefined;
  style: (value: string) => Record<string, string> | undefined;
  color: (value: string) => Record<string, string> | undefined;
  top: (value: string) => Record<string, string> | undefined;
  right: (value: string) => Record<string, string> | undefined;
  bottom: (value: string) => Record<string, string> | undefined;
  left: (value: string) => Record<string, string> | undefined;
};

const suffix =
  (suffix: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = directional(value);

    if (!longhand) return;

    const result: Record<string, string> = {};
    for (const key in longhand) {
      result[`border-${key}-${suffix}`] = longhand[key];
    }
    return sortProperties(result);
  };

const direction =
  (direction: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = all(value);

    if (!longhand) return;

    const filtered: Record<string, string> = {};
    for (const key in longhand) {
      if (key === "boxSizing" && longhand[key]) {
        filtered[key] = longhand[key];
      } else if (longhand[key as keyof BorderProperties]) {
        filtered[`border-${direction}-${key}`] = longhand[key as keyof BorderProperties] as string;
      }
    }
    return sortProperties(filtered);
  };

const all = (value: string): BorderResult | undefined => {
  const values = normalizeColor(value).split(/\s+/);
  const first = values[0];

  // Handle special case: border values with box-sizing
  if (values.length === 4) {
    const [width, style, color, boxSizing] = values;

    // Check if first 3 values are valid border values and 4th is valid box-sizing
    if (
      (WIDTH.test(width) || isLength(width)) &&
      STYLE.test(style) &&
      isColor(color) &&
      (boxSizing === "border-box" || boxSizing === "content-box")
    ) {
      return {
        width,
        style,
        color,
        boxSizing,
      };
    }
  }

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(first)) {
    return {
      width: first,
      style: first,
      color: first,
    };
  }

  const result: BorderProperties = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (WIDTH.test(v) || isLength(v)) {
      if (result.width) return;
      result.width = v;
    } else if (STYLE.test(v)) {
      if (result.style) return;
      result.style = v;
    } else if (isColor(v)) {
      if (result.color) return;
      result.color = v;
    } else {
      return;
    }
  }

  return result;
};

const border: BorderFunction = (value: string): Record<string, string> | undefined => {
  const longhand = all(value);

  if (!longhand) return;

  const result: Record<string, string> = {};

  // Handle box-sizing separately
  if (longhand.boxSizing) {
    result["box-sizing"] = longhand.boxSizing;
  }

  // Use defaults for missing properties
  // Per CSS spec, the default values for border shorthand are:
  //   width: 'medium', style: 'none', color: 'currentcolor'
  // See: https://drafts.csswg.org/css-backgrounds-3/#border-shorthand
  const width = longhand.width || "medium";
  const style = longhand.style || "none";
  const color = longhand.color || "currentcolor";

  // Expand all three border properties
  const widthProps = border.width(width);
  const styleProps = border.style(style);
  const colorProps = border.color(color);

  if (widthProps) Object.assign(result, widthProps);
  if (styleProps) Object.assign(result, styleProps);
  if (colorProps) Object.assign(result, colorProps);

  return sortProperties(result);
};

border.width = suffix("width");
border.style = suffix("style");
border.color = suffix("color");
border.top = direction("top");
border.right = direction("right");
border.bottom = direction("bottom");
border.left = direction("left");

export default border;


=== File: src/color-utils.ts ===
// b_path:: src/color-utils.ts
// Color utility functions - replacing external dependencies for better self-containment

export const CSS_COLOR_NAMES: Record<string, string> = {
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#00FFFF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000000",
  blanchedalmond: "#FFEBCD",
  blue: "#0000FF",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#00FFFF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  darkgreen: "#006400",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#FF00FF",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  lightgreen: "#90EE90",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#00FF00",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#FF00FF",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#FF0000",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFFFFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FFFF00",
  yellowgreen: "#9ACD32",
};

export function cssUrlRegex(): RegExp {
  return /url\((.*?)\)/gi;
}

export function hexColorRegex(opts?: { strict?: boolean }): RegExp {
  opts = opts && typeof opts === "object" ? opts : {};
  return opts.strict
    ? /^#([a-f0-9]{3,4}|[a-f0-9]{4}(?:[a-f0-9]{2}){1,2})\b$/i
    : /#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})\b/gi;
}

export function hslRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)$/
    : /hsl\(\s*(\d+)\s*,\s*(\d*(?:\.\d+)?%)\s*,\s*(\d*(?:\.\d+)?%)\)/gi;
}

export function hslaRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)$/
    : /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*(\d*(?:\.\d+)?)\)/gi;
}

export function rgbRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/
    : /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/gi;
}

export function rgbaRegex(options?: { exact?: boolean }): RegExp {
  options = options || {};
  return options.exact
    ? /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)$/
    : /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d*(?:\.\d+)?)\)/gi;
}


=== File: src/column-rule.ts ===
// b_path:: src/column-rule.ts
import { sortProperties } from "./index";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function columnRule(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(values[0])) {
    return sortProperties({
      "column-rule-width": values[0],
      "column-rule-style": values[0],
      "column-rule-color": values[0],
    });
  }

  const parsed: { width?: string; style?: string; color?: string } = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (isLength(v) || WIDTH.test(v)) {
      if (parsed.width) return;
      parsed.width = v;
    } else if (STYLE.test(v)) {
      if (parsed.style) return;
      parsed.style = v;
    } else if (isColor(v)) {
      if (parsed.color) return;
      parsed.color = v;
    } else {
      return;
    }
  }

  // Use defaults for missing properties
  // Per CSS spec, the default values for column-rule shorthand are:
  //   width: 'medium', style: 'none', color: 'currentcolor'
  // See: https://drafts.csswg.org/css-multicol-1/#propdef-column-rule
  return sortProperties({
    "column-rule-width": parsed.width || "medium",
    "column-rule-style": parsed.style || "none",
    "column-rule-color": parsed.color || "currentcolor",
  });
}


=== File: src/columns.ts ===
// b_path:: src/columns.ts
import { sortProperties } from "./index";
import isLength from "./is-length";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return sortProperties({
      "column-width": value,
      "column-count": value,
    });
  }

  // Split values on whitespace
  const values = value.trim().split(/\s+/);

  // Validate value count - max 2 values
  if (values.length > 2) {
    return undefined;
  }

  // Regex patterns for type detection
  const INTEGER = /^[0-9]+$/;
  const KEYWORD = /^(auto)$/i;

  const result: Record<string, string> = {};

  // Separate specific values from auto values
  const specificValues: Array<{ value: string; type: "width" | "count" }> = [];
  const autoValues: string[] = [];

  for (const val of values) {
    if (KEYWORD.test(val)) {
      autoValues.push(val);
    } else if (isLength(val)) {
      specificValues.push({ value: val, type: "width" });
    } else if (INTEGER.test(val)) {
      specificValues.push({ value: val, type: "count" });
    } else {
      return undefined; // Invalid value
    }
  }

  // Check for conflicts in specific values
  if (
    specificValues.filter((v) => v.type === "width").length > 1 ||
    specificValues.filter((v) => v.type === "count").length > 1
  ) {
    return undefined; // Multiple values for same property
  }

  // Assign specific values first
  for (const { value, type } of specificValues) {
    result[`column-${type}`] = value;
  }

  // Assign auto values to remaining properties
  for (const autoValue of autoValues) {
    if (!result["column-width"]) {
      result["column-width"] = autoValue;
    } else if (!result["column-count"]) {
      result["column-count"] = autoValue;
    } else {
      return undefined; // No available property for auto
    }
  }

  return sortProperties(result);
};


=== File: src/contain-intrinsic-size.ts ===
// b_path:: src/contain-intrinsic-size.ts
import isLength from "./is-length";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "contain-intrinsic-width": value,
      "contain-intrinsic-height": value,
    };
  }

  // Split values on whitespace
  const tokens = value.trim().split(/\s+/);

  // Validate token count - max 4 tokens (for two auto pairs)
  if (tokens.length > 4 || tokens.length === 0) {
    return undefined;
  }

  const result: Record<string, string> = {};

  // Parse tokens into width and height values
  let i = 0;
  const parseValue = (): string | undefined => {
    if (i >= tokens.length) return undefined;

    const token = tokens[i++];
    if (token.toLowerCase() === "auto") {
      if (i >= tokens.length) return undefined; // auto must be followed by something
      const nextToken = tokens[i++];
      if (nextToken.toLowerCase() === "none") {
        return "auto none";
      } else if (isLength(nextToken)) {
        return `auto ${nextToken}`;
      } else {
        return undefined; // invalid after auto
      }
    } else if (token.toLowerCase() === "none") {
      return "none";
    } else if (isLength(token)) {
      return token;
    } else {
      return undefined; // invalid token
    }
  };

  // Parse width value
  const widthValue = parseValue();
  if (widthValue === undefined) return undefined;

  // Parse height value (if present)
  const heightValue = parseValue();

  // If only one value provided, apply to both
  if (heightValue === undefined) {
    result["contain-intrinsic-width"] = widthValue;
    result["contain-intrinsic-height"] = widthValue;
  } else {
    // Two values provided
    result["contain-intrinsic-width"] = widthValue;
    result["contain-intrinsic-height"] = heightValue;
  }

  // Ensure no extra tokens
  if (i !== tokens.length) return undefined;

  return result;
};


=== File: src/css-defaults.ts ===
// b_path:: src/css-defaults.ts

/**
 * CSS default values for directional properties (kebab-case).
 * Used for partial longhand expansion when expandPartialLonghand option is enabled.
 */
export const CSS_DEFAULTS: Record<string, string> = {
  // Border width
  "border-top-width": "medium",
  "border-right-width": "medium",
  "border-bottom-width": "medium",
  "border-left-width": "medium",

  // Border style
  "border-top-style": "none",
  "border-right-style": "none",
  "border-bottom-style": "none",
  "border-left-style": "none",

  // Border color
  "border-top-color": "currentcolor",
  "border-right-color": "currentcolor",
  "border-bottom-color": "currentcolor",
  "border-left-color": "currentcolor",

  // Border radius
  "border-top-left-radius": "0",
  "border-top-right-radius": "0",
  "border-bottom-right-radius": "0",
  "border-bottom-left-radius": "0",

  // Margin
  "margin-top": "0",
  "margin-right": "0",
  "margin-bottom": "0",
  "margin-left": "0",

  // Padding
  "padding-top": "0",
  "padding-right": "0",
  "padding-bottom": "0",
  "padding-left": "0",

  // Positioning
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto",

  // Scroll margin
  "scroll-margin-top": "0",
  "scroll-margin-right": "0",
  "scroll-margin-bottom": "0",
  "scroll-margin-left": "0",

  // Scroll padding
  "scroll-padding-top": "auto",
  "scroll-padding-right": "auto",
  "scroll-padding-bottom": "auto",
  "scroll-padding-left": "auto",
};


=== File: src/directional.ts ===
// b_path:: src/directional.ts

/**
 * Cache for directional property expansion results.
 * Improves performance for repeated calls with same values.
 */
const directionalCache = new Map<string, Record<string, string>>();
const MAX_CACHE_SIZE = 1000;

/**
 * Expands directional values (top, right, bottom, left) from CSS shorthand notation.
 * Supports 1-4 value syntax and caches results for performance.
 *
 * @param value - CSS value string with 1-4 space-separated values
 * @returns Object with top, right, bottom, left properties, or undefined if invalid
 *
 * @example
 * directional('10px') // { top: '10px', right: '10px', bottom: '10px', left: '10px' }
 * directional('10px 20px') // { top: '10px', right: '20px', bottom: '10px', left: '20px' }
 * directional('10px 20px 30px') // { top: '10px', right: '20px', bottom: '30px', left: '20px' }
 * directional('10px 20px 30px 40px') // { top: '10px', right: '20px', bottom: '30px', left: '40px' }
 */
export default function directional(value: string): Record<string, string> | undefined {
  // Check cache first
  const cached = directionalCache.get(value);
  if (cached) return cached;

  const values = value.split(/\s+/);

  if (values.length === 1) values.splice(0, 1, ...Array.from({ length: 4 }, () => values[0]));
  else if (values.length === 2) values.push(...values);
  else if (values.length === 3) values.push(values[1]);
  else if (values.length > 4) return;

  const result = ["top", "right", "bottom", "left"].reduce(
    (acc: Record<string, string>, direction: string, i: number) => {
      acc[direction] = values[i];
      return acc;
    },
    {}
  );

  // Cache result with size limit
  if (directionalCache.size >= MAX_CACHE_SIZE) {
    // Remove oldest entry (first key)
    const firstKey = directionalCache.keys().next().value;
    if (firstKey !== undefined) {
      directionalCache.delete(firstKey);
    }
  }
  directionalCache.set(value, result);

  return result;
}


=== File: src/expand-directional.ts ===
// b_path:: src/expand-directional.ts

import { CSS_DEFAULTS } from "./css-defaults";

const DIRECTIONAL_SIDES = ["top", "right", "bottom", "left"] as const;
const CORNER_POSITIONS = ["top-left", "top-right", "bottom-right", "bottom-left"] as const;

/**
 * Base key for grouping bare directional properties (top, right, bottom, left).
 * These map to the CSS `inset` logical property group.
 */
const INSET_BASE_KEY = "inset";

/**
 * Base key for grouping border-radius corner properties.
 * These share the same "border-radius" shorthand.
 */
const BORDER_RADIUS_BASE_KEY = "border-radius";

/**
 * Grouping information for side-based directional properties (top, right, bottom, left).
 */
interface DirectionalGroup {
  prefix: string;
  suffix: string;
  sides: Set<string>;
}

/**
 * Grouping information for corner-based properties (top-left, top-right, etc.).
 */
interface CornerGroup {
  corners: Set<string>;
}

/**
 * Builds a full CSS property name from prefix, side, and suffix components.
 *
 * @param prefix - Property prefix (e.g., "border-", "margin-", or "")
 * @param side - Directional side (e.g., "top", "right", "bottom", "left")
 * @param suffix - Property suffix (e.g., "-width", "-style", or "")
 * @returns Full property name (e.g., "border-top-width", "margin-top", "top")
 *
 * @example
 * buildPropertyName("border-", "top", "-width") // → "border-top-width"
 * buildPropertyName("margin-", "top", "") // → "margin-top"
 * buildPropertyName("", "top", "") // → "top"
 */
function buildPropertyName(prefix: string, side: string, suffix: string): string {
  if (prefix === "" && suffix === "") {
    // Just the side (top, right, bottom, left)
    return side;
  }
  if (suffix === "") {
    // prefix-side (e.g., "margin-top")
    return `${prefix}${side}`;
  }
  // prefix-side-suffix (e.g., "border-top-width")
  return `${prefix}${side}${suffix}`;
}

/**
 * Expands partial directional properties by filling in missing sides with CSS defaults.
 *
 * Scans the result for directional keywords (top, right, bottom, left), groups them by
 * base property, and fills in any missing sides with their CSS default values.
 *
 * @param result - Object with CSS properties (kebab-case)
 * @returns New object with expanded directional properties
 *
 * @example
 * expandDirectionalProperties({ 'border-top-width': '1px' })
 * // → {
 * //     'border-top-width': '1px',
 * //     'border-right-width': 'medium',
 * //     'border-bottom-width': 'medium',
 * //     'border-left-width': 'medium'
 * //   }
 */
export function expandDirectionalProperties(
  result: Record<string, string>
): Record<string, string> {
  const groups = new Map<string, DirectionalGroup>();
  const cornerGroups = new Map<string, CornerGroup>();

  // Pre-compile regex for directional property matching (more efficient than string operations)
  // Matches: -(top|right|bottom|left)- or -(top|right|bottom|left)$ or exact side
  const directionalRegex = /^(.*)-(top|right|bottom|left)(-(.*))?$|^(top|right|bottom|left)$/;

  // Detect directional properties and group by base
  for (const property of Object.keys(result)) {
    // Check for border-radius corner properties first
    const cornerMatch = property.match(
      /^border-(top-left|top-right|bottom-right|bottom-left)-radius$/
    );
    if (cornerMatch) {
      const corner = cornerMatch[1];
      if (!cornerGroups.has(BORDER_RADIUS_BASE_KEY)) {
        cornerGroups.set(BORDER_RADIUS_BASE_KEY, { corners: new Set() });
      }
      cornerGroups.get(BORDER_RADIUS_BASE_KEY)!.corners.add(corner);
      continue;
    }

    // Check for side-based directional properties using pre-compiled regex
    const match = property.match(directionalRegex);
    if (match) {
      // match[1] = prefix (if side in middle or end), match[2] = side (if hyphenated),
      // match[4] = suffix (if side in middle), match[5] = bare side
      const side = match[2] || match[5]; // Side from hyphenated or bare match

      if (!side) continue; // Shouldn't happen, but defensive check

      if (match[5]) {
        // Bare side property (e.g., "top")
        const prefix = "";
        const suffix = "";
        const baseKey = INSET_BASE_KEY;

        if (!groups.has(baseKey)) {
          groups.set(baseKey, { prefix, suffix, sides: new Set() });
        }
        groups.get(baseKey)!.sides.add(side);
      } else if (match[4] !== undefined) {
        // Side in the middle (e.g., border-top-width)
        const prefix = match[1] ? `${match[1]}-` : ""; // Include trailing hyphen
        const suffix = match[4] ? `-${match[4]}` : ""; // Include leading hyphen
        const baseKey = `${prefix}|${suffix}`; // Normalized grouping key

        if (!groups.has(baseKey)) {
          groups.set(baseKey, { prefix, suffix, sides: new Set() });
        }
        groups.get(baseKey)!.sides.add(side);
      } else {
        // Side at the end (e.g., margin-top)
        const prefix = match[1] ? `${match[1]}-` : ""; // Include trailing hyphen
        const suffix = "";
        const baseKey = prefix || side; // Use prefix as key; fallback to side

        if (!groups.has(baseKey)) {
          groups.set(baseKey, { prefix, suffix, sides: new Set() });
        }
        groups.get(baseKey)!.sides.add(side);
      }
    }
  }

  // If no directional groups found, return as-is
  if (groups.size === 0 && cornerGroups.size === 0) {
    return result;
  }

  const expanded: Record<string, string> = { ...result };

  // Fill missing corners for border-radius
  for (const [, group] of cornerGroups) {
    const { corners } = group;

    // If all 4 corners present, nothing to expand
    if (corners.size === 4) {
      continue;
    }

    // Add missing corners
    for (const corner of CORNER_POSITIONS) {
      if (!corners.has(corner)) {
        const fullProperty = `border-${corner}-radius`;
        const defaultValue = CSS_DEFAULTS[fullProperty];

        if (defaultValue) {
          expanded[fullProperty] = defaultValue;
        }
      }
    }
  }

  // Fill missing sides with defaults
  for (const [, group] of groups) {
    const { prefix, suffix, sides } = group;

    // If all 4 sides present, nothing to expand
    if (sides.size === 4) {
      continue;
    }

    // Add missing sides
    for (const side of DIRECTIONAL_SIDES) {
      if (!sides.has(side)) {
        const fullProperty = buildPropertyName(prefix, side, suffix);
        const defaultValue = CSS_DEFAULTS[fullProperty];

        if (defaultValue) {
          expanded[fullProperty] = defaultValue;
        }
      }
    }
  }

  return expanded;
}


=== File: src/flex-flow.ts ===
// b_path:: src/flex-flow.ts
export default function (value: string): Record<string, string> | undefined {
  // Handle global CSS keywords first
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "flex-direction": value,
      "flex-wrap": value,
    };
  }

  // Parse normal values
  const parts = value.trim().split(/\s+/);
  if (parts.length > 2) return undefined;

  // Define keyword patterns
  const directionPattern = /^(row|row-reverse|column|column-reverse)$/i;
  const wrapPattern = /^(nowrap|wrap|wrap-reverse)$/i;

  // Value classification logic
  let direction: string | undefined;
  let wrap: string | undefined;

  for (const part of parts) {
    if (directionPattern.test(part)) {
      if (direction !== undefined) return undefined; // duplicate
      direction = part;
    } else if (wrapPattern.test(part)) {
      if (wrap !== undefined) return undefined; // duplicate
      wrap = part;
    } else {
      return undefined; // invalid
    }
  }

  // Return result
  const result: Record<string, string> = {};
  if (direction) result["flex-direction"] = direction;
  if (wrap) result["flex-wrap"] = wrap;
  return Object.keys(result).length > 0 ? result : undefined;
}


=== File: src/flex.ts ===
// b_path:: src/flex.ts
import isLength from "./is-length";

export default function (value: string): Record<string, string> | undefined {
  // Handle global CSS keywords
  if (/^(inherit|unset|revert)$/i.test(value)) {
    return {
      "flex-grow": value,
      "flex-shrink": value,
      "flex-basis": value,
    };
  }

  // Special case for initial
  if (value === "initial") {
    return {
      "flex-grow": "0",
      "flex-shrink": "1",
      "flex-basis": "auto",
    };
  }

  // Handle special keyword values
  if (value === "none") {
    return {
      "flex-grow": "0",
      "flex-shrink": "0",
      "flex-basis": "auto",
    };
  }

  if (value === "auto") {
    return {
      "flex-grow": "1",
      "flex-shrink": "1",
      "flex-basis": "auto",
    };
  }

  // Parse normal values
  const parts = value.trim().split(/\s+/);
  if (parts.length > 3 || parts.length === 0) return undefined;

  // Define value type detection patterns
  const numberPattern = /^[+-]?([0-9]*\.)?[0-9]+$/;
  const flexBasisKeywordPattern = /^(auto|content|max-content|min-content|fit-content)$/i;
  const fitContentFn = /^fit-content\(\s*[^)]+\s*\)$/i;

  // Classify each value by type
  const classified: Array<{ value: string; type: "number" | "basis" }> = [];
  for (const part of parts) {
    if (numberPattern.test(part)) {
      classified.push({ value: part, type: "number" });
    } else if (flexBasisKeywordPattern.test(part) || isLength(part) || fitContentFn.test(part)) {
      classified.push({ value: part, type: "basis" });
    } else {
      return undefined;
    }
  }

  // Handle unitless zero as basis in three-value form
  if (classified.length === 3 && classified[2].type === "number" && isLength(classified[2].value)) {
    classified[2] = { type: "basis", value: classified[2].value };
  }

  // Apply expansion rules based on value count
  if (classified.length === 1) {
    const [val] = classified;
    if (val.type === "number") {
      return {
        "flex-grow": val.value,
        "flex-shrink": "1",
        "flex-basis": "0%",
      };
    } else {
      return {
        "flex-grow": "1",
        "flex-shrink": "1",
        "flex-basis": val.value,
      };
    }
  } else if (classified.length === 2) {
    const [first, second] = classified;
    if (first.type === "number" && second.type === "number") {
      return {
        "flex-grow": first.value,
        "flex-shrink": second.value,
        "flex-basis": "0%",
      };
    } else if (first.type === "number" && second.type === "basis") {
      return {
        "flex-grow": first.value,
        "flex-shrink": "1",
        "flex-basis": second.value,
      };
    } else if (first.type === "basis" && second.type === "number") {
      return {
        "flex-grow": second.value,
        "flex-shrink": "1",
        "flex-basis": first.value,
      };
    } else {
      return undefined;
    }
  } else if (classified.length === 3) {
    const [first, second, third] = classified;
    if (first.type === "number" && second.type === "number" && third.type === "basis") {
      return {
        "flex-grow": first.value,
        "flex-shrink": second.value,
        "flex-basis": third.value,
      };
    } else {
      return undefined;
    }
  }

  return undefined;
}


=== File: src/font.ts ===
// b_path:: src/font.ts
/**
 * Copied from https://github.com/bramstein/css-font-parser
 */

import { sortProperties } from "./index";

/**
 * @enum {number}
 */
const states = {
  VARIATION: 1,
  LINE_HEIGHT: 2,
  FONT_FAMILY: 3,
};

interface FontResult {
  "font-family": string[];
  "font-size"?: string;
  "line-height"?: string;
  "font-style"?: string;
  "font-weight"?: string;
  "font-variant"?: string;
  "font-stretch"?: string;
}

function parse(input: string): FontResult | null {
  let state = states.VARIATION;
  let buffer = "";
  const result: FontResult = {
    "font-family": [],
  };

  for (let i = 0; i < input.length; i += 1) {
    const c = input.charAt(i);
    if (state === states.FONT_FAMILY && (c === '"' || c === "'")) {
      let index = i + 1;

      // consume the entire string
      do {
        index = input.indexOf(c, index) + 1;
        if (!index) {
          // If a string is not closed by a ' or " return null.
          // TODO: Check to see if this is correct.
          return null;
        }
      } while (input.charAt(index - 2) === "\\");

      result["font-family"].push(input.slice(i + 1, index - 1).replace(/\\('|")/g, "$1"));

      i = index - 1;
      buffer = "";
    } else if (state === states.FONT_FAMILY && c === ",") {
      if (!/^\s*$/.test(buffer)) {
        result["font-family"].push(buffer.replace(/^\s+|\s+$/, "").replace(/\s+/g, " "));
        buffer = "";
      }
    } else if (state === states.VARIATION && (c === " " || c === "/")) {
      if (
        /^((xx|x)-large|(xx|s)-small|small|large|medium)$/.test(buffer) ||
        /^(larg|small)er$/.test(buffer) ||
        /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/.test(buffer)
      ) {
        state = c === "/" ? states.LINE_HEIGHT : states.FONT_FAMILY;
        result["font-size"] = buffer;
      } else if (/^(italic|oblique)$/.test(buffer)) {
        result["font-style"] = buffer;
      } else if (/^small-caps$/.test(buffer)) {
        result["font-variant"] = buffer;
      } else if (/^(bold(er)?|lighter|normal|[1-9]00)$/.test(buffer)) {
        result["font-weight"] = buffer;
      } else if (/^((ultra|extra|semi)-)?(condensed|expanded)$/.test(buffer)) {
        result["font-stretch"] = buffer;
      }
      buffer = "";
    } else if (state === states.LINE_HEIGHT && c === " ") {
      if (
        /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)?$/.test(buffer)
      ) {
        result["line-height"] = buffer;
      }
      state = states.FONT_FAMILY;
      buffer = "";
    } else {
      buffer += c;
    }
  }

  if (state === states.FONT_FAMILY && !/^\s*$/.test(buffer)) {
    result["font-family"].push(buffer.replace(/^\s+|\s+$/, "").replace(/\s+/g, " "));
  }

  if (result["font-size"] && result["font-family"].length) {
    return result;
  } else {
    return null;
  }
}

export default function font(input: string): Record<string, string> | undefined {
  if (/^(inherit|initial)$/.test(input)) {
    return sortProperties({
      "font-size": input,
      "line-height": input,
      "font-style": input,
      "font-weight": input,
      "font-variant": input,
      "font-stretch": input,
      "font-family": input,
    });
  }

  input = input.replace(/\s*\/\s*/, "/");
  const result = parse(input);

  if (result) {
    const finalResult: Record<string, string> = {};

    // Set defaults for properties that should always be present
    // Per CSS spec, font shorthand resets these to initial values if not specified
    const defaults = {
      "font-style": "normal",
      "font-variant": "normal",
      "font-weight": "normal",
      "font-stretch": "normal",
    };

    // Apply defaults first
    Object.assign(finalResult, defaults);

    // Then override with parsed values
    for (const key in result) {
      if (key === "font-family") {
        finalResult[key] = result[key]
          .map((family: string) =>
            /^(serif|sans-serif|monospace|cursive|fantasy)$/.test(family) ? family : `"${family}"`
          )
          .join(", ");
      } else if (result[key as keyof FontResult]) {
        finalResult[key] = result[key as keyof FontResult] as string;
      }
    }
    return sortProperties(finalResult);
  }

  return undefined;
}


=== File: src/grid-area.ts ===
// b_path:: src/grid-area.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-row-start": value,
      "grid-column-start": value,
      "grid-row-end": value,
      "grid-column-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 4 parts
  if (parts.length > 4) {
    return undefined;
  }

  // Validate all parts
  for (const part of parts) {
    if (!parseGridLine(part.trim())) {
      return undefined;
    }
  }

  let rowStart: string, columnStart: string, rowEnd: string, columnEnd: string;

  if (parts.length === 1) {
    // 1 value: row-start (or all if custom-ident)
    const val = parts[0].trim();
    if (/^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(val) && !/^(auto|span|\d)/i.test(val)) {
      // Custom-ident: all four get the same value
      rowStart = columnStart = rowEnd = columnEnd = val;
    } else {
      // Otherwise: row-start gets value, others auto
      rowStart = val;
      columnStart = "auto";
      rowEnd = "auto";
      columnEnd = "auto";
    }
  } else if (parts.length === 2) {
    // 2 values: row-start / column-start
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = getDefaultEnd(rowStart);
    columnEnd = getDefaultEnd(columnStart);
  } else if (parts.length === 3) {
    // 3 values: row-start / column-start / row-end
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = parts[2].trim();
    columnEnd = getDefaultEnd(columnStart);
  } else {
    // 4 values: row-start / column-start / row-end / column-end
    rowStart = parts[0].trim();
    columnStart = parts[1].trim();
    rowEnd = parts[2].trim();
    columnEnd = parts[3].trim();
  }

  return {
    "grid-row-start": rowStart,
    "grid-column-start": columnStart,
    "grid-row-end": rowEnd,
    "grid-column-end": columnEnd,
  };
};


=== File: src/grid-column.ts ===
// b_path:: src/grid-column.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-column-start": value,
      "grid-column-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 2 parts
  if (parts.length > 2) {
    return undefined;
  }

  // Handle single value
  if (parts.length === 1) {
    const startValue = parts[0].trim();
    if (!parseGridLine(startValue)) {
      return undefined;
    }
    const endValue = getDefaultEnd(startValue);
    return {
      "grid-column-start": startValue,
      "grid-column-end": endValue,
    };
  }

  // Handle two values
  if (parts.length === 2) {
    const startValue = parts[0].trim();
    const endValue = parts[1].trim();
    if (!parseGridLine(startValue) || !parseGridLine(endValue)) {
      return undefined;
    }
    return {
      "grid-column-start": startValue,
      "grid-column-end": endValue,
    };
  }

  return undefined;
};


=== File: src/grid-line.ts ===
// b_path:: src/grid-line.ts

export function isCustomIdent(s: string): boolean {
  return /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(s);
}

function isInteger(s: string): boolean {
  return /^[+-]?[0-9]+$/.test(s) && Number(s) !== 0;
}

export function parseGridLine(value: string): boolean {
  const tokens = value.trim().split(/\s+/);
  if (tokens.length === 0) return false;

  if (tokens[0] === "span") {
    if (tokens.length < 2 || tokens.length > 3) return false;
    const rest = tokens.slice(1);
    let seenInt = false;
    let seenIdent = false;
    for (const token of rest) {
      if (isInteger(token)) {
        if (seenInt) return false;
        seenInt = true;
      } else if (isCustomIdent(token)) {
        if (seenIdent) return false;
        seenIdent = true;
      } else {
        return false;
      }
    }
    return seenInt || seenIdent;
  } else {
    if (tokens.length > 2) return false;
    let seenInt = false;
    let seenIdent = false;
    for (const token of tokens) {
      if (isInteger(token)) {
        if (seenInt) return false;
        seenInt = true;
      } else if (isCustomIdent(token)) {
        if (seenIdent) return false;
        seenIdent = true;
      } else {
        return false;
      }
    }
    return seenInt || seenIdent;
  }
}

export function getDefaultEnd(start: string): string {
  return isCustomIdent(start) ? start : "auto";
}


=== File: src/grid-row.ts ===
// b_path:: src/grid-row.ts
import { getDefaultEnd, parseGridLine } from "./grid-line";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-row-start": value,
      "grid-row-end": value,
    };
  }

  // Split values on slash
  const parts = value.trim().split(/\s*\/\s*/);

  // Validate part count - max 2 parts
  if (parts.length > 2) {
    return undefined;
  }

  // Handle single value
  if (parts.length === 1) {
    const startValue = parts[0].trim();
    if (!parseGridLine(startValue)) {
      return undefined;
    }
    const endValue = getDefaultEnd(startValue);
    return {
      "grid-row-start": startValue,
      "grid-row-end": endValue,
    };
  }

  // Handle two values
  if (parts.length === 2) {
    const startValue = parts[0].trim();
    const endValue = parts[1].trim();
    if (!parseGridLine(startValue) || !parseGridLine(endValue)) {
      return undefined;
    }
    return {
      "grid-row-start": startValue,
      "grid-row-end": endValue,
    };
  }

  return undefined;
};


=== File: src/grid.ts ===
// b_path:: src/grid.ts

import * as csstree from "css-tree";

// CSS default values for grid properties
export const GRID_DEFAULTS = {
  "grid-template-rows": "none",
  "grid-template-columns": "none",
  "grid-template-areas": "none",
  "grid-auto-rows": "auto",
  "grid-auto-columns": "auto",
  "grid-auto-flow": "row",
  "row-gap": "normal",
  "column-gap": "normal",
} as const;

/**
 * Parses value and returns segments and slash count
 */
function parseValueAndGetSegments(
  value: string
): { leftSegment: csstree.CssNode[]; rightSegment: csstree.CssNode[]; slashCount: number } | null {
  try {
    const ast = csstree.parse(value.trim(), { context: "value" }) as csstree.Value;

    // Find top-level / operator positions
    const slashIndices: number[] = [];

    csstree.walk(ast, {
      visit: "Value",
      enter: (node: csstree.Value) => {
        if (node.children) {
          let index = 0;
          node.children.forEach((child) => {
            if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
              slashIndices.push(index);
            }
            index++;
          });
        }
      },
    });

    const slashCount = slashIndices.length;
    if (slashCount > 1) {
      return null; // Multiple slashes not allowed
    }

    const childrenArray = listToArray(ast.children);
    if (slashCount === 0) {
      return { leftSegment: childrenArray, rightSegment: [], slashCount: 0 };
    }

    const slashIndex = slashIndices[0];
    const leftSegment = childrenArray.slice(0, slashIndex);
    const rightSegment = childrenArray.slice(slashIndex + 1);

    return { leftSegment, rightSegment, slashCount };
  } catch {
    return null;
  }
}

/**
 * Detects which grid shorthand form is being used
 */
function detectGridForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): "template" | "explicit-rows" | "explicit-columns" | null {
  if (rightSegment.length === 0) {
    // No slash, check if it's valid track list or ASCII art
    return "template";
  }

  // Check for auto-flow in each segment
  let hasAutoFlowLeft = false;
  let hasAutoFlowRight = false;

  for (const node of leftSegment) {
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      hasAutoFlowLeft = true;
      break;
    }
  }

  for (const node of rightSegment) {
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      hasAutoFlowRight = true;
      break;
    }
  }

  if (hasAutoFlowRight) {
    return "explicit-rows";
  } else if (hasAutoFlowLeft) {
    return "explicit-columns";
  } else {
    return "template";
  }
}

/**
 * Helper to convert List to array
 */
function listToArray<T>(list: csstree.List<T>): T[] {
  const arr: T[] = [];
  for (const item of list) {
    arr.push(item);
  }
  return arr;
}

/**
 * Separates areas (strings) and tracks (other nodes) from a segment
 */
function separateAreasAndTracks(segmentNodes: csstree.CssNode[]): {
  areas: string | undefined;
  tracks: string | undefined;
} {
  const strings: string[] = [];
  const tracks: csstree.CssNode[] = [];

  for (const node of segmentNodes) {
    if (node.type === "String") {
      strings.push((node as csstree.StringNode).value);
    } else if (node.type !== "WhiteSpace") {
      tracks.push(node);
    }
  }

  let areas: string | undefined;
  if (strings.length > 0) {
    // Validate that all rows have the same number of columns
    const rows = strings.map((s) => s.trim().split(/\s+/));
    const columnCount = rows[0]?.length || 0;
    if (columnCount === 0 || !rows.every((row) => row.length === columnCount)) {
      return { areas: undefined, tracks: undefined }; // Invalid
    }
    areas = strings.map((s) => `"${s.trim()}"`).join(" ");
  }

  let tracksStr: string | undefined;
  if (tracks.length > 0) {
    tracksStr = parseTrackList(tracks);
  }

  return { areas, tracks: tracksStr };
}

/**
 * Parses track list (rows or columns) into CSS string
 */
function parseTrackList(segmentNodes: csstree.CssNode[]): string | undefined {
  const validNodes: csstree.CssNode[] = [];

  for (const node of segmentNodes) {
    if (
      node.type === "Identifier" &&
      ["auto", "min-content", "max-content"].includes((node as csstree.Identifier).name)
    ) {
      validNodes.push(node);
    } else if (node.type === "Dimension") {
      validNodes.push(node);
    } else if (node.type === "Percentage") {
      validNodes.push(node);
    } else if (
      node.type === "Function" &&
      ["repeat", "minmax", "fit-content"].includes((node as csstree.FunctionNode).name)
    ) {
      validNodes.push(node);
    } else if (node.type === "Number" && (node as csstree.NumberNode).value === "0") {
      validNodes.push(node);
    } else if (node.type === "Parentheses") {
      // Named grid lines like [line1]
      validNodes.push(node);
    }
  }

  if (validNodes.length === 0) {
    return undefined;
  }

  // Generate CSS from the valid nodes
  const generatedParts: string[] = [];
  for (const node of validNodes) {
    generatedParts.push(csstree.generate(node));
  }

  return generatedParts.join(" ");
}

/**
 * Parses template form: <grid-template>
 */
function parseTemplateForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  let templateAreas: string | undefined;
  let templateRows: string | undefined;
  let templateColumns: string | undefined;

  if (rightSegment.length === 0) {
    // No slash - could be just rows, but not areas
    const { areas, tracks } = separateAreasAndTracks(leftSegment);
    if (areas) {
      return undefined; // Strings without slash not supported
    }
    templateRows = tracks;
    if (!templateRows) {
      return undefined; // Invalid
    }
  } else {
    const { areas: leftAreas, tracks: leftTracks } = separateAreasAndTracks(leftSegment);
    const { tracks: rightTracks } = separateAreasAndTracks(rightSegment);

    // Template form logic:
    // - If left has areas, then left areas + left tracks (as rows) + right columns
    // - If left has tracks but no areas, then left rows + right columns
    // - If no slash and left has areas, then just areas
    // - If no slash and left has tracks, then just rows

    if (leftAreas) {
      templateAreas = leftAreas;
      templateRows = leftTracks; // Interleaved track sizes become rows
      templateColumns = rightTracks;
      if (!templateColumns) {
        return undefined;
      }
    } else if (leftTracks) {
      templateRows = leftTracks;
      templateColumns = rightTracks;
      if (!templateColumns) {
        return undefined;
      }
    } else {
      return undefined; // Invalid
    }
  }

  return {
    "grid-template-rows": templateRows || GRID_DEFAULTS["grid-template-rows"],
    "grid-template-columns": templateColumns || GRID_DEFAULTS["grid-template-columns"],
    "grid-template-areas": templateAreas || GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": GRID_DEFAULTS["grid-auto-flow"],
    "row-gap": GRID_DEFAULTS["row-gap"],
    "column-gap": GRID_DEFAULTS["column-gap"],
  };
}

/**
 * Parses explicit rows form: <rows> / auto-flow [dense] [<auto-columns>]
 */
function parseExplicitRowsForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  // Check if right segment starts with auto-flow
  let firstNonWhiteSpace: csstree.CssNode | undefined;
  for (const node of rightSegment) {
    if (node.type !== "WhiteSpace") {
      firstNonWhiteSpace = node;
      break;
    }
  }
  if (
    !firstNonWhiteSpace ||
    firstNonWhiteSpace.type !== "Identifier" ||
    (firstNonWhiteSpace as csstree.Identifier).name !== "auto-flow"
  ) {
    return undefined;
  }

  // Left side: template rows
  const templateRows = parseTrackList(leftSegment);
  if (!templateRows) {
    return undefined;
  }

  // Right side: auto-flow [dense] [auto-columns]
  let autoFlow = "column";
  let autoColumns: string | undefined;

  // Find auto-flow and dense
  let hasDense = false;
  let autoColumnsStart = -1;

  for (let i = 0; i < rightSegment.length; i++) {
    const node = rightSegment[i];
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      // Next might be dense
      if (
        i + 1 < rightSegment.length &&
        rightSegment[i + 1].type === "Identifier" &&
        (rightSegment[i + 1] as csstree.Identifier).name === "dense"
      ) {
        hasDense = true;
        autoColumnsStart = i + 2;
      } else {
        autoColumnsStart = i + 1;
      }
      break;
    }
  }

  if (hasDense) {
    autoFlow = "column dense";
  }

  // Parse auto-columns if present
  if (autoColumnsStart >= 0 && autoColumnsStart < rightSegment.length) {
    const autoColumnsSegment = rightSegment.slice(autoColumnsStart);
    autoColumns = parseTrackList(autoColumnsSegment);
  }

  return {
    "grid-template-rows": templateRows,
    "grid-template-columns": GRID_DEFAULTS["grid-template-columns"],
    "grid-template-areas": GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": autoColumns || GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": autoFlow,
    "row-gap": GRID_DEFAULTS["row-gap"],
    "column-gap": GRID_DEFAULTS["column-gap"],
  };
}

/**
 * Parses explicit columns form: auto-flow [dense] [<auto-rows>] / <columns>
 */
function parseExplicitColumnsForm(
  leftSegment: csstree.CssNode[],
  rightSegment: csstree.CssNode[]
): Record<string, string> | undefined {
  // Check if left segment starts with auto-flow
  let firstNonWhiteSpace: csstree.CssNode | undefined;
  for (const node of leftSegment) {
    if (node.type !== "WhiteSpace") {
      firstNonWhiteSpace = node;
      break;
    }
  }
  if (
    !firstNonWhiteSpace ||
    firstNonWhiteSpace.type !== "Identifier" ||
    (firstNonWhiteSpace as csstree.Identifier).name !== "auto-flow"
  ) {
    return undefined;
  }

  // Right side: template columns
  const templateColumns = parseTrackList(rightSegment);
  if (!templateColumns) {
    return undefined;
  }

  // Left side: auto-flow [dense] [auto-rows]
  let autoFlow = "row";
  let autoRows: string | undefined;

  // Find auto-flow and dense
  let hasDense = false;
  let autoRowsStart = -1;

  for (let i = 0; i < leftSegment.length; i++) {
    const node = leftSegment[i];
    if (node.type === "Identifier" && (node as csstree.Identifier).name === "auto-flow") {
      // Next might be dense
      if (
        i + 1 < leftSegment.length &&
        leftSegment[i + 1].type === "Identifier" &&
        (leftSegment[i + 1] as csstree.Identifier).name === "dense"
      ) {
        hasDense = true;
        autoRowsStart = i + 2;
      } else {
        autoRowsStart = i + 1;
      }
      break;
    }
  }

  if (hasDense) {
    autoFlow = "row dense";
  }

  // Parse auto-rows if present
  if (autoRowsStart >= 0 && autoRowsStart < leftSegment.length) {
    const autoRowsSegment = leftSegment.slice(autoRowsStart);
    autoRows = parseTrackList(autoRowsSegment);
  }

  return {
    "grid-template-rows": GRID_DEFAULTS["grid-template-rows"],
    "grid-template-columns": templateColumns,
    "grid-template-areas": GRID_DEFAULTS["grid-template-areas"],
    "grid-auto-rows": autoRows || GRID_DEFAULTS["grid-auto-rows"],
    "grid-auto-columns": GRID_DEFAULTS["grid-auto-columns"],
    "grid-auto-flow": autoFlow,
    "row-gap": GRID_DEFAULTS["row-gap"],
    "column-gap": GRID_DEFAULTS["column-gap"],
  };
}

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "grid-template-rows": value,
      "grid-template-columns": value,
      "grid-template-areas": value,
      "grid-auto-rows": value,
      "grid-auto-columns": value,
      "grid-auto-flow": value,
      "row-gap": value,
      "column-gap": value,
    };
  }

  // Handle none keyword
  if (value.trim().toLowerCase() === "none") {
    return { ...GRID_DEFAULTS };
  }

  // Parse value and get segments
  const segments = parseValueAndGetSegments(value);
  if (!segments) {
    return undefined; // Invalid (e.g., multiple slashes)
  }

  // Detect form and parse accordingly
  const form = detectGridForm(segments.leftSegment, segments.rightSegment);
  switch (form) {
    case "template":
      return parseTemplateForm(segments.leftSegment, segments.rightSegment);
    case "explicit-rows":
      return parseExplicitRowsForm(segments.leftSegment, segments.rightSegment);
    case "explicit-columns":
      return parseExplicitColumnsForm(segments.leftSegment, segments.rightSegment);
    default:
      return undefined;
  }
};


=== File: src/index.ts ===
// b_path:: src/index.ts

import animation from "./animation";
import background from "./background";
import border from "./border";
import borderRadius from "./border-radius";
import columnRule from "./column-rule";
import columns from "./columns";
import containIntrinsicSize from "./contain-intrinsic-size";
import directional from "./directional";
import { expandDirectionalProperties } from "./expand-directional";
import flex from "./flex";
import flexFlow from "./flex-flow";
import font from "./font";
import grid from "./grid";
import gridArea from "./grid-area";
import gridColumn from "./grid-column";
import gridRow from "./grid-row";
import listStyle from "./list-style";
import mask from "./mask";
import offset from "./offset";
import outline from "./outline";
import overflow from "./overflow";
import placeContent from "./place-content";
import placeItems from "./place-items";
import placeSelf from "./place-self";
import type { BStyleWarning, ExpandOptions, ExpandResult, PropertyGrouping } from "./schema";
import { FORMAT_CSS, FORMAT_JS, GROUPING_BY_PROPERTY, GROUPING_BY_SIDE } from "./schema";
import textDecoration from "./text-decoration";
import textEmphasis from "./text-emphasis";
import transition from "./transition";
import { validate } from "./validate";

/**
 * Removes all CSS comments from the input string.
 * Uses a character-by-character scanning approach that safely handles multi-line comments.
 */
function stripComments(css: string): string {
  // Remove all CSS comments /* ... */
  // This function scans character-by-character to handle multi-line comments safely
  let result = "";
  let i = 0;

  while (i < css.length) {
    // Check for comment start
    if (css[i] === "/" && css[i + 1] === "*") {
      // Find comment end
      let j = i + 2;
      while (j < css.length) {
        if (css[j] === "*" && css[j + 1] === "/") {
          // Skip the comment, replace with a space to preserve token boundaries
          result += " ";
          i = j + 2;
          break;
        }
        j++;
      }
      // If we didn't find a closing */, treat rest of string as comment and stop
      if (j >= css.length) {
        i = css.length;
      }
    } else {
      result += css[i];
      i++;
    }
  }

  return result;
}

function parseInputString(input: string): string[] {
  const declarations: string[] = [];
  let current = "";
  let i = 0;

  while (i < input.length) {
    const char = input[i];
    const nextChar = input[i + 1];

    // Handle escaped characters
    if (char === "\\" && nextChar) {
      current += char + nextChar;
      i += 2;
      continue;
    }

    // Track context
    if (char === '"' || char === "'") {
      // Find the closing quote, handling escaped quotes
      let quoteEnd = i + 1;
      while (quoteEnd < input.length) {
        if (input[quoteEnd] === char && input[quoteEnd - 1] !== "\\") {
          break;
        }
        quoteEnd++;
      }
      if (quoteEnd < input.length) {
        current += input.substring(i, quoteEnd + 1);
        i = quoteEnd + 1;
        continue;
      }
    }

    // Handle parentheses (for functions like url(), calc(), etc.)
    if (char === "(") {
      let parenCount = 1;
      let parenEnd = i + 1;
      while (parenEnd < input.length && parenCount > 0) {
        if (input[parenEnd] === "(") parenCount++;
        if (input[parenEnd] === ")") parenCount--;
        parenEnd++;
      }
      if (parenCount === 0) {
        current += input.substring(i, parenEnd);
        i = parenEnd;
        continue;
      }
    }

    // Handle square brackets (for attribute selectors, etc.)
    if (char === "[") {
      const bracketEnd = input.indexOf("]", i + 1);
      if (bracketEnd !== -1) {
        current += input.substring(i, bracketEnd + 1);
        i = bracketEnd + 1;
        continue;
      }
    }

    // Split on semicolons only when not in any special context
    if (char === ";") {
      declarations.push(current.trim());
      current = "";
    } else {
      current += char;
    }

    i++;
  }

  // Add the last declaration if it exists
  if (current.trim()) {
    declarations.push(current.trim());
  }

  // Filter out empty declarations
  return declarations.filter((decl) => decl.length > 0);
}

function parseCssDeclaration(declaration: string): { property: string; value: string } | null {
  const trimmed = declaration.trim();
  const colonIndex = trimmed.indexOf(":");

  if (colonIndex === -1) return null;

  const property = trimmed.slice(0, colonIndex).trim();
  const value = trimmed.slice(colonIndex + 1).trim();

  if (!property || !value) return null;

  return { property, value };
}

const prefix =
  (prefix: string) =>
  (value: string): Record<string, string> | undefined => {
    const longhand = directional(value);

    if (!longhand) return;

    const result: Record<string, string> = {};
    for (const key in longhand) {
      result[`${prefix}-${key}`] = longhand[key];
    }
    return result;
  };

const shorthand: Record<string, (value: string) => Record<string, string> | undefined> = {
  animation: animation,
  background: background,
  border: border,
  "border-bottom": border.bottom,
  "border-color": border.color,
  "border-left": border.left,
  "border-radius": borderRadius,
  "border-right": border.right,
  "border-style": border.style,
  "border-top": border.top,
  "border-width": border.width,
  columns: columns,
  "column-rule": columnRule,
  "contain-intrinsic-size": containIntrinsicSize,
  flex: flex,
  "flex-flow": flexFlow,
  font: font,
  grid: grid,
  "grid-area": gridArea,
  "grid-column": gridColumn,
  "grid-row": gridRow,
  inset: directional,
  "list-style": listStyle,
  mask: mask,
  margin: prefix("margin"),
  offset: offset,
  outline: outline,
  overflow: overflow,
  padding: prefix("padding"),
  "place-content": placeContent,
  "place-items": placeItems,
  "place-self": placeSelf,
  "text-decoration": textDecoration,
  "text-emphasis": textEmphasis,
  transition: transition,
};

const PROPERTY_ORDER_MAP: Record<string, number> = {
  // Grid properties (indices 0-11)
  "grid-row-start": 0,
  "grid-row-end": 1,
  "grid-column-start": 2,
  "grid-column-end": 3,
  "grid-template-rows": 4,
  "grid-template-columns": 5,
  "grid-template-areas": 6,
  "grid-auto-rows": 7,
  "grid-auto-columns": 8,
  "grid-auto-flow": 9,
  "row-gap": 10,
  "column-gap": 11,

  // Animation properties (indices 20-27)
  "animation-name": 20,
  "animation-duration": 21,
  "animation-timing-function": 22,
  "animation-delay": 23,
  "animation-iteration-count": 24,
  "animation-direction": 25,
  "animation-fill-mode": 26,
  "animation-play-state": 27,

  // Transition properties (indices 30-33)
  "transition-property": 30,
  "transition-duration": 31,
  "transition-timing-function": 32,
  "transition-delay": 33,

  // Background properties (indices 40-47)
  "background-image": 40,
  "background-position": 41,
  "background-size": 42,
  "background-repeat": 43,
  "background-attachment": 44,
  "background-origin": 45,
  "background-clip": 46,
  "background-color": 47,

  // Font properties (indices 50-56)
  "font-style": 50,
  "font-variant": 51,
  "font-weight": 52,
  "font-stretch": 53,
  "font-size": 54,
  "line-height": 55,
  "font-family": 56,

  // Flex properties (indices 60-64)
  "flex-grow": 60,
  "flex-shrink": 61,
  "flex-basis": 62,
  "flex-direction": 63,
  "flex-wrap": 64,

  // Border directional properties (indices 70-84)
  "border-top-width": 70,
  "border-top-style": 71,
  "border-top-color": 72,
  "border-right-width": 73,
  "border-right-style": 74,
  "border-right-color": 75,
  "border-bottom-width": 76,
  "border-bottom-style": 77,
  "border-bottom-color": 78,
  "border-left-width": 79,
  "border-left-style": 80,
  "border-left-color": 81,
  "border-width": 82,
  "border-style": 83,
  "border-color": 84,

  // Border-radius properties (indices 90-93)
  "border-top-left-radius": 90,
  "border-top-right-radius": 91,
  "border-bottom-right-radius": 92,
  "border-bottom-left-radius": 93,

  // Outline properties (indices 100-102)
  "outline-width": 100,
  "outline-style": 101,
  "outline-color": 102,

  // Column-rule properties (indices 110-112)
  "column-rule-width": 110,
  "column-rule-style": 111,
  "column-rule-color": 112,

  // Columns properties (indices 115-116)
  "column-width": 115,
  "column-count": 116,

  // List-style properties (indices 120-122)
  "list-style-type": 120,
  "list-style-position": 121,
  "list-style-image": 122,

  // Text-decoration properties (indices 130-133)
  "text-decoration-line": 130,
  "text-decoration-style": 131,
  "text-decoration-color": 132,
  "text-decoration-thickness": 133,

  // Overflow properties (indices 140-141)
  "overflow-x": 140,
  "overflow-y": 141,

  // Place properties (indices 150-155)
  "align-items": 150,
  "justify-items": 151,
  "align-content": 152,
  "justify-content": 153,
  "align-self": 154,
  "justify-self": 155,

  // Directional properties - margin (indices 200-203)
  "margin-top": 200,
  "margin-right": 201,
  "margin-bottom": 202,
  "margin-left": 203,

  // Directional properties - padding (indices 210-213)
  "padding-top": 210,
  "padding-right": 211,
  "padding-bottom": 212,
  "padding-left": 213,

  // Directional properties - inset (indices 220-223)
  top: 220,
  right: 221,
  bottom: 222,
  left: 223,

  // Mask properties (indices 230-237)
  "mask-image": 230,
  "mask-mode": 231,
  "mask-position": 232,
  "mask-size": 233,
  "mask-repeat": 234,
  "mask-origin": 235,
  "mask-clip": 236,
  "mask-composite": 237,

  // Offset properties (indices 240-244)
  "offset-position": 240,
  "offset-path": 241,
  "offset-distance": 242,
  "offset-rotate": 243,
  "offset-anchor": 244,

  // Text-emphasis properties (indices 250-252)
  "text-emphasis-style": 250,
  "text-emphasis-color": 251,
  "text-emphasis-position": 252,

  // Contain-intrinsic-size properties (indices 260-261)
  "contain-intrinsic-width": 260,
  "contain-intrinsic-height": 261,
};

/**
 * Converts a kebab-case CSS property name to camelCase for JavaScript.
 *
 * @param property - CSS property name in kebab-case (e.g., "margin-top")
 * @returns Property name in camelCase (e.g., "marginTop")
 *
 * @example
 * kebabToCamelCase('margin-top') // → 'marginTop'
 * kebabToCamelCase('text-decoration-line') // → 'textDecorationLine'
 */
function kebabToCamelCase(property: string): string {
  return property.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}

/**
 * Sorts an object's properties according to CSS specification order defined in PROPERTY_ORDER_MAP.
 *
 * @param obj - Object with CSS properties to sort
 * @param grouping - Grouping strategy from PropertyGrouping enum
 * @returns New object with properties sorted according to the specified strategy
 *
 * @example
 * // by-property: groups all properties of same type together
 * sortProperties({ 'margin-top': '5px', 'border-top-width': '1px' })
 * // → { 'border-top-width': '1px', 'margin-top': '5px' }
 *
 * @example
 * // by-side: groups all properties of same side together
 * sortProperties({ 'margin-bottom': '5px', 'border-top-width': '1px' }, 'by-side')
 * // → { 'border-top-width': '1px', 'margin-bottom': '5px' } (top before bottom)
 */
function sortProperties(
  obj: Record<string, string>,
  grouping: PropertyGrouping = GROUPING_BY_PROPERTY
): Record<string, string> {
  if (grouping === GROUPING_BY_SIDE) {
    return sortPropertiesBySide(obj);
  }
  return sortPropertiesByProperty(obj);
}

/**
 * Helper to extract property metadata for directional grouping.
 * Identifies the side (top/right/bottom/left) and base property name.
 *
 * @param prop - CSS property name to analyze
 * @returns Metadata object with side, sideIndex, and base property
 *
 * @example
 * getPropertyMetadata('border-top-width')
 * // → { side: 'top', sideIndex: 0, base: 'border' }
 *
 * @example
 * getPropertyMetadata('font-size')
 * // → { side: null, sideIndex: -1, base: 'font' }
 */
function getPropertyMetadata(prop: string): {
  side: string | null;
  sideIndex: number;
  base: string;
} {
  const parts = prop.split("-");
  const sides = ["top", "right", "bottom", "left"];
  const side = parts.find((p) => sides.includes(p)) || null;
  const sideIndex = side ? sides.indexOf(side) : -1;
  const base = parts[0];

  return { side, sideIndex, base };
}

/**
 * Sort properties by property type (default CSS spec order).
 * Groups all properties of the same type together (e.g., all margins, then all borders).
 *
 * @param obj - Object with CSS properties to sort
 * @returns New object with properties sorted by type
 */
function sortPropertiesByProperty(obj: Record<string, string>): Record<string, string> {
  const sortedEntries = Object.entries(obj).sort(([a], [b]) => {
    const orderA = PROPERTY_ORDER_MAP[a];
    const orderB = PROPERTY_ORDER_MAP[b];

    if (orderA !== undefined && orderB !== undefined) {
      return orderA - orderB;
    }
    if (orderA !== undefined) return -1;
    if (orderB !== undefined) return 1;
    return a.localeCompare(b);
  });

  return Object.fromEntries(sortedEntries);
}

/**
 * Sort properties by directional side.
 * Groups all properties of the same side together (e.g., all top properties, then all right properties).
 * Useful for debugging and understanding box model relationships.
 *
 * @param obj - Object with CSS properties to sort
 * @returns New object with properties sorted by side
 */
function sortPropertiesBySide(obj: Record<string, string>): Record<string, string> {
  const sortedEntries = Object.entries(obj).sort(([a], [b]) => {
    const metaA = getPropertyMetadata(a);
    const metaB = getPropertyMetadata(b);

    // Both have sides - sort by side first, then by property order within that side
    if (metaA.side && metaB.side) {
      if (metaA.sideIndex !== metaB.sideIndex) {
        return metaA.sideIndex - metaB.sideIndex;
      }
      // Same side - sort by CSS spec order to maintain proper ordering within the side
      const orderA = PROPERTY_ORDER_MAP[a] ?? 999999;
      const orderB = PROPERTY_ORDER_MAP[b] ?? 999999;
      return orderA - orderB;
    }

    // If only one has a side, non-directional properties come first (by their spec order)
    // This handles mixed cases like font-size mixed with margin-top
    if (!metaA.side && metaB.side) {
      const orderA = PROPERTY_ORDER_MAP[a] ?? 999999;
      // Put non-directional before directional if they have lower spec order
      if (orderA < 200) return -1; // Most non-directional properties are < 200
      return 1;
    }
    if (metaA.side && !metaB.side) {
      const orderB = PROPERTY_ORDER_MAP[b] ?? 999999;
      if (orderB < 200) return 1;
      return -1;
    }

    // Neither has sides - use normal property order
    const orderA = PROPERTY_ORDER_MAP[a] ?? 999999;
    const orderB = PROPERTY_ORDER_MAP[b] ?? 999999;
    if (orderA !== orderB) return orderA - orderB;
    return a.localeCompare(b);
  });

  return Object.fromEntries(sortedEntries);
}

function objectToCss(
  obj: Record<string, string>,
  indent: number,
  separator: string,
  propertyGrouping: PropertyGrouping = GROUPING_BY_PROPERTY
): string {
  const indentStr = "  ".repeat(indent);

  // Sort properties using the specified grouping strategy
  const sorted = sortProperties(obj, propertyGrouping);
  const sortedEntries = Object.entries(sorted);

  return sortedEntries.map(([key, value]) => `${indentStr}${key}: ${value};`).join(separator);
}

/**
 * Expands CSS shorthand properties into their longhand equivalents.
 *
 * @param input - CSS declaration(s) to expand (e.g., "margin: 10px 20px;")
 * @param options - Configuration options for expansion behavior
 * @returns Object containing expansion result, success status, and any issues
 *
 * @example
 * // Basic expansion
 * expand('margin: 10px 20px;')
 * // → { ok: true, result: 'margin-top: 10px;\nmargin-right: 20px;...', issues: [] }
 *
 * // JavaScript object format
 * expand('padding: 1rem;', { format: 'js' })
 * // → { ok: true, result: { 'padding-top': '1rem', ... }, issues: [] }
 *
 * // Multiple declarations with conflict resolution
 * expand('margin: 10px; margin-top: 20px;', { format: 'js' })
 * // → { ok: true, result: { 'margin-top': '20px', 'margin-right': '10px', ... }, issues: [] }
 */
function expand(input: string, options: Partial<ExpandOptions> = {}): ExpandResult {
  // Strip comments first to avoid parsing issues
  const cleanedInput = stripComments(input);

  // Merge partial options with defaults from schema
  const {
    format = FORMAT_CSS,
    indent = 0,
    separator = "\n",
    propertyGrouping = GROUPING_BY_PROPERTY,
    expandPartialLonghand = false,
  } = options;

  // Validate the input CSS directly (assume it's valid CSS)
  const validation = validate(cleanedInput);

  const inputs = parseInputString(cleanedInput);
  const results: (Record<string, string> | string)[] = [];
  const issues: BStyleWarning[] = [];
  const resultMetadata: Array<{ isShorthand: boolean; properties: Set<string> }> = [];

  for (const item of inputs) {
    const parsed = parseCssDeclaration(item);
    if (!parsed) {
      continue; // Skip invalid declarations
    }

    const { property, value } = parsed;
    const normalized = value.trim();
    // Safe check for !important without ReDoS vulnerability
    const important = normalized.endsWith("!important") && /\s/.test(normalized.slice(-11, -10));

    // Handle !important detection and warning
    if (important) {
      issues.push({
        property,
        name: "important-detected",
        formattedWarning: `!important flag detected in '${property}' and has been ignored. Shorthand expansion does not support !important.`,
      });

      const result: Record<string, string> = {};
      result[property] = normalized;
      results.push(result);
      resultMetadata.push({ isShorthand: false, properties: new Set([property]) });
      continue;
    }

    const parse = shorthand[property];
    const longhand = parse?.(normalized);

    if (!longhand) {
      // For non-shorthand properties, still include them in the result
      // but as-is (no expansion needed) - validation will catch invalid ones

      const result: Record<string, string> = {};
      result[property] = normalized;
      results.push(result);
      resultMetadata.push({ isShorthand: false, properties: new Set([property]) });

      // Add warning for unparseable shorthands only if CSS is actually invalid
      if (property in shorthand) {
        issues.push({
          property,
          name: "expansion-failed",
          formattedWarning: `Could not expand shorthand property '${property}' with value '${normalized}'. Returning original shorthand.`,
        });
      }
      continue;
    }

    const result: Record<string, string> = longhand;
    results.push(result);
    resultMetadata.push({ isShorthand: true, properties: new Set(Object.keys(result)) });
  }

  /**
   * Resolves conflicts between shorthand and longhand properties according to CSS cascade rules.
   *
   * When a longhand property (e.g., margin-top) appears after a shorthand (e.g., margin),
   * the longhand overrides that specific property from the shorthand expansion.
   * When a shorthand appears after a longhand, the shorthand replaces all related longhands.
   *
   * @param results - Array of CSS declaration objects (either objects or strings)
   * @param metadata - Array of metadata describing each result (shorthand vs longhand, properties affected)
   * @returns Cleaned array with conflicts resolved
   *
   * @example
   * // Input: ['margin: 10px', 'margin-top: 20px']
   * // Output: margin-top from the shorthand is removed, replaced by explicit margin-top: 20px
   *
   * @example
   * // Input: ['margin-top: 20px', 'margin: 10px']
   * // Output: margin-top: 20px is removed, replaced by margin: 10px expansion
   */
  function removeConflictingProperties(
    results: (Record<string, string> | string)[],
    metadata: Array<{ isShorthand: boolean; properties: Set<string> }>
  ): (Record<string, string> | string)[] {
    const cleanedResults: (Record<string, string> | string)[] = [];
    // Maintain a running map of property name to the index of the last setting result
    const propertyToResultIndex = new Map<string, number>();

    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const meta = metadata[i];

      // For CSS strings, we need to convert them back to objects for conflict resolution
      let resultObj: Record<string, string>;
      if (typeof result === "string") {
        // Parse CSS string back to object for conflict resolution
        resultObj = {};
        const cssLines = result.split(";").filter((line) => line.trim());
        for (const line of cssLines) {
          const colonIndex = line.indexOf(":");
          if (colonIndex !== -1) {
            const prop = line.slice(0, colonIndex).trim();
            const value = line.slice(colonIndex + 1).trim();
            resultObj[prop] = value;
          }
        }
      } else {
        resultObj = { ...result };
      }

      // Handle conflicts based on whether current result is from shorthand expansion
      if (!meta.isShorthand) {
        // Current result is NOT from shorthand expansion - check for conflicts with earlier shorthand results
        for (const prop of meta.properties) {
          const earlierIndex = propertyToResultIndex.get(prop);
          if (earlierIndex !== undefined) {
            const earlierResult = cleanedResults[earlierIndex];
            const earlierMeta = metadata[earlierIndex];

            // Only check earlier shorthand results for conflicts
            if (earlierMeta.isShorthand && earlierMeta.properties.has(prop)) {
              // Remove the conflicting property from the earlier shorthand result
              if (typeof earlierResult === "string") {
                // Parse, remove property, and convert back to CSS string
                const earlierObj: Record<string, string> = {};
                const cssLines = earlierResult.split(";").filter((line) => line.trim());
                for (const line of cssLines) {
                  const colonIndex = line.indexOf(":");
                  if (colonIndex !== -1) {
                    const earlierProp = line.slice(0, colonIndex).trim();
                    const value = line.slice(colonIndex + 1).trim();
                    if (earlierProp !== prop) {
                      earlierObj[earlierProp] = value;
                    }
                  }
                }
                cleanedResults[earlierIndex] = objectToCss(
                  earlierObj,
                  indent,
                  separator,
                  propertyGrouping
                );
              } else {
                delete earlierResult[prop];
              }
              // Update metadata to remove the property
              earlierMeta.properties.delete(prop);
            }
          }
        }
      } else {
        // Current result IS from shorthand expansion - check for conflicts with earlier non-shorthand results
        // Gate this behind CSS format only to mirror JS merge behavior
        if (format === FORMAT_CSS) {
          for (const prop of meta.properties) {
            const earlierIndex = propertyToResultIndex.get(prop);
            if (earlierIndex !== undefined) {
              const earlierResult = cleanedResults[earlierIndex];
              const earlierMeta = metadata[earlierIndex];

              // Only check earlier non-shorthand results for conflicts
              if (!earlierMeta.isShorthand && earlierMeta.properties.has(prop)) {
                // Remove the conflicting property from the earlier non-shorthand result
                if (typeof earlierResult === "string") {
                  // Parse, remove property, and convert back to CSS string
                  const earlierObj: Record<string, string> = {};
                  const cssLines = earlierResult.split(";").filter((line) => line.trim());
                  for (const line of cssLines) {
                    const colonIndex = line.indexOf(":");
                    if (colonIndex !== -1) {
                      const earlierProp = line.slice(0, colonIndex).trim();
                      const value = line.slice(colonIndex + 1).trim();
                      if (earlierProp !== prop) {
                        earlierObj[earlierProp] = value;
                      }
                    }
                  }
                  cleanedResults[earlierIndex] = objectToCss(
                    earlierObj,
                    indent,
                    separator,
                    propertyGrouping
                  );
                } else {
                  delete earlierResult[prop];
                }
                // Update metadata to remove the property
                earlierMeta.properties.delete(prop);
              }
            }
          }
        }
      }

      // Add the current result (CSS string or object)
      cleanedResults.push(result);

      // Update the property map with the current result index for all properties in this result
      for (const prop of meta.properties) {
        propertyToResultIndex.set(prop, cleanedResults.length - 1);
      }
    }

    return cleanedResults;
  }

  /**
   * Helper to apply partial longhand expansion if enabled.
   */
  const applyPartialExpansion = (obj: Record<string, string>): Record<string, string> => {
    return expandPartialLonghand ? expandDirectionalProperties(obj) : obj;
  };

  let finalResult: Record<string, string> | string | undefined;

  // Apply conflict resolution for shorthand/longhand property overrides
  const cleanedResults = removeConflictingProperties(results, resultMetadata);

  if (cleanedResults.length === 0) {
    finalResult = undefined;
  } else if (cleanedResults.length === 1) {
    const result = cleanedResults[0];
    if (format === FORMAT_CSS && typeof result === "object") {
      const resultToProcess = applyPartialExpansion(result);
      finalResult = objectToCss(resultToProcess, indent, separator, propertyGrouping);
    } else if (format === FORMAT_JS && typeof result === "object") {
      const resultToProcess = applyPartialExpansion(result);
      // Sort and convert to camelCase for JS format
      const sorted = sortProperties(resultToProcess, propertyGrouping);
      const camelCased: Record<string, string> = {};
      for (const [key, value] of Object.entries(sorted)) {
        camelCased[kebabToCamelCase(key)] = value;
      }
      finalResult = camelCased;
    } else {
      finalResult = result;
    }
  } else {
    if (format === FORMAT_CSS) {
      // For CSS format with multiple declarations, we need to merge objects first
      // then convert to CSS to respect property grouping across declarations
      const mergedObject: Record<string, string> = {};

      for (const result of cleanedResults) {
        if (typeof result === "object" && result) {
          Object.assign(mergedObject, result);
        }
      }

      // If we have a merged object, convert it to CSS with proper grouping
      if (Object.keys(mergedObject).length > 0) {
        const resultToProcess = applyPartialExpansion(mergedObject);
        finalResult = objectToCss(resultToProcess, indent, separator, propertyGrouping);
      } else {
        // Fallback for non-object results (shouldn't normally happen)
        const cssResults = cleanedResults.map((result) =>
          typeof result === "object"
            ? objectToCss(result, indent, separator, propertyGrouping)
            : result
        );
        finalResult = cssResults.join(separator);
      }
    } else {
      // format === FORMAT_JS (js) - merge objects with simple "later wins" logic
      const mergedResult: Record<string, string> = {};
      for (const result of cleanedResults) {
        if (typeof result === "object" && result) {
          Object.assign(mergedResult, result);
        }
      }

      const resultToProcess = applyPartialExpansion(mergedResult);

      // Sort the merged result according to the specified grouping strategy
      const sorted = sortProperties(resultToProcess, propertyGrouping);

      // Convert property names to camelCase for JavaScript
      const camelCased: Record<string, string> = {};
      for (const [key, value] of Object.entries(sorted)) {
        camelCased[kebabToCamelCase(key)] = value;
      }

      finalResult = camelCased;
    }
  }

  // Determine ok status: false if errors, true if warnings only or no issues
  const ok = validation.errors.length === 0;

  // Combine errors, warnings, and our custom issues
  const allIssues = [...validation.errors, ...validation.warnings, ...issues];

  return {
    ok,
    result: finalResult,
    issues: allIssues,
  };
}

// Export named functions only (no default export to avoid CJS/ESM ambiguity)
export { expand, validate, sortProperties, PROPERTY_ORDER_MAP };

// Re-export types for convenience
export type {
  AnimationLayer,
  AnimationResult,
  BackgroundLayer,
  BackgroundResult,
  BStyleWarning,
  ExpandOptions,
  ExpandResult,
  Format,
  MaskLayer,
  MaskResult,
  PropertyGrouping,
  StylesheetValidation,
  TransitionLayer,
  TransitionResult,
} from "./schema";
// Export enum values and constants for runtime use
export {
  FORMAT_CSS,
  FORMAT_JS,
  FORMAT_VALUES,
  GROUPING_BY_PROPERTY,
  GROUPING_BY_SIDE,
  PROPERTY_GROUPING_VALUES,
} from "./schema";


=== File: src/is-angle.ts ===
// b_path:: src/is-angle.ts
const ANGLE = /^(\+|-)?([0-9]*\.?[0-9]+)(deg|rad|turn|grad)$/i;
const ZERO = /^(\+|-)?(0*\.)?0+$/;

export default function isAngle(value: string): boolean {
  return ANGLE.test(value) || ZERO.test(value);
}


=== File: src/is-color.ts ===
// b_path:: src/is-color.ts
import {
  CSS_COLOR_NAMES,
  hexColorRegex,
  hslaRegex,
  hslRegex,
  rgbaRegex,
  rgbRegex,
} from "./color-utils";

const HEX = new RegExp(`^${hexColorRegex().source}$`, "i");
const HSLA = hslaRegex({ exact: true });
const HSL = hslRegex({ exact: true });
const RGB = rgbRegex({ exact: true });
const RGBA = rgbaRegex({ exact: true });

/**
 * Cache for color validation results.
 * Improves performance for repeated color checks.
 */
const colorCache = new Map<string, boolean>();
const MAX_CACHE_SIZE = 500;

/**
 * Checks if a string value represents a valid CSS color.
 * Supports named colors, hex, rgb, rgba, hsl, hsla, and CSS custom properties.
 * Results are cached for performance.
 *
 * @param value - The CSS value to check
 * @returns true if the value is a valid color, false otherwise
 *
 * @example
 * isColor('red') // true
 * isColor('#ff0000') // true
 * isColor('rgb(255, 0, 0)') // true
 * isColor('var(--primary-color)') // true
 * isColor('10px') // false
 */
export default function isColor(value: string): boolean {
  // Check cache first
  const cached = colorCache.get(value);
  if (cached !== undefined) return cached;

  const lowerValue = value.toLowerCase();

  // Support CSS custom property (var name)
  if (/^var\(\s*--[a-zA-Z0-9-_]+\s*\)$/.test(lowerValue)) {
    colorCache.set(value, true);
    return true;
  }

  const result =
    !!CSS_COLOR_NAMES[lowerValue] ||
    lowerValue === "currentcolor" ||
    lowerValue === "transparent" ||
    HEX.test(lowerValue) ||
    HSLA.test(lowerValue) ||
    HSL.test(lowerValue) ||
    RGB.test(lowerValue) ||
    RGBA.test(lowerValue);

  // Cache result with size limit
  if (colorCache.size >= MAX_CACHE_SIZE) {
    const firstKey = colorCache.keys().next().value;
    if (firstKey !== undefined) {
      colorCache.delete(firstKey);
    }
  }
  colorCache.set(value, result);

  return result;
}


=== File: src/is-length.ts ===
// b_path:: src/is-length.ts
const LENGTH = /^(\+|-)?([0-9]*\.)?[0-9]+(em|ex|ch|rem|vh|vw|vmin|vmax|px|mm|cm|in|pt|pc|%)$/i;
const ZERO = /^(\+|-)?(0*\.)?0+$/;

export default function isLength(value: string): boolean {
  return LENGTH.test(value) || ZERO.test(value);
}


=== File: src/is-time.ts ===
// b_path:: src/is-time.ts
// Utility to detect CSS time values for transition-duration and transition-delay parsing
const TIME = /^[+-]?(\d*\.)?\d+(m?s)$/i;

export default function isTime(value: string): boolean {
  return TIME.test(value);
}


=== File: src/is-timing-function.ts ===
// b_path:: src/is-timing-function.ts
// Utility to detect CSS timing function values for transition-timing-function parsing
const TIMING_KEYWORDS = /^(ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end)$/i;
const TIMING_FUNCTIONS = /^(cubic-bezier|steps)\s*\(/i;

function hasBalancedParentheses(value: string): boolean {
  let openCount = 0;
  for (const char of value) {
    if (char === "(") {
      openCount++;
    } else if (char === ")") {
      openCount--;
      if (openCount < 0) {
        return false;
      }
    }
  }
  return openCount === 0;
}

export default function isTimingFunction(value: string): boolean {
  // Check for timing function keywords
  if (TIMING_KEYWORDS.test(value)) {
    return true;
  }

  // Check for timing function functions with balanced parentheses
  if (TIMING_FUNCTIONS.test(value)) {
    return hasBalancedParentheses(value);
  }

  return false;
}


=== File: src/layer-parser-utils.ts ===
// b_path:: src/layer-parser-utils.ts

/**
 * Shared utilities for parsing multi-layer CSS properties (background, mask, animation, transition).
 * Eliminates ~360 lines of duplication across layer-parsing modules.
 */

/**
 * Detects if a CSS value contains top-level commas (indicating multiple layers).
 * Ignores commas inside parentheses/brackets (functions, rgba(), etc.).
 *
 * @param value - CSS value to analyze
 * @param detectFunctions - If true, also return true for values with function calls
 * @returns true if multi-layer parsing is needed
 *
 * @example
 * hasTopLevelCommas('url(a.png), url(b.png)') // → true (multiple layers)
 * hasTopLevelCommas('rgba(0,0,0,0.5)')        // → false (comma inside function)
 * hasTopLevelCommas('cubic-bezier(0,0,1,1)', true) // → true (has function)
 */
export function hasTopLevelCommas(value: string, detectFunctions = false): boolean {
  let parenDepth = 0;
  let bracketDepth = 0;
  let hasFunctions = false;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
      hasFunctions = true;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this indicates multiple layers
      return true;
    }
  }

  // Optionally detect functions (for animation/transition timing functions)
  return detectFunctions && hasFunctions;
}

/**
 * Splits a CSS value into layers at top-level commas, respecting nested functions.
 *
 * @param value - CSS value to split
 * @returns Array of layer strings (trimmed)
 *
 * @example
 * splitLayers('url(a.png) center, url(b.png) top')
 * // → ['url(a.png) center', 'url(b.png) top']
 *
 * splitLayers('rgba(0,0,0,0.5)')
 * // → ['rgba(0,0,0,0.5)']
 */
export function splitLayers(value: string): string[] {
  const layers: string[] = [];
  let currentLayer = "";
  let parenDepth = 0;
  let bracketDepth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      parenDepth++;
    } else if (char === ")") {
      parenDepth--;
    } else if (char === "[") {
      bracketDepth++;
    } else if (char === "]") {
      bracketDepth--;
    } else if (char === "," && parenDepth === 0 && bracketDepth === 0) {
      // Found a comma at the top level - this separates layers
      layers.push(currentLayer.trim());
      currentLayer = "";
      continue;
    }

    currentLayer += char;
  }

  // Add the last layer
  if (currentLayer.trim()) {
    layers.push(currentLayer.trim());
  }

  return layers;
}

/**
 * Generic layer parsing factory for multi-layer CSS properties.
 * Handles splitting, parsing, and error handling uniformly.
 *
 * @param value - CSS value to parse
 * @param parseSingleLayer - Function to parse a single layer string
 * @returns Parsed layers or undefined on error
 *
 * @example
 * // Background parsing
 * parseLayersGeneric(
 *   'url(a.png) center, url(b.png) top',
 *   parseBackgroundLayer
 * )
 */
export function parseLayersGeneric<T>(
  value: string,
  parseSingleLayer: (layerValue: string) => T | undefined
): T[] | undefined {
  try {
    // Split into layers
    const layerStrings = splitLayers(value);
    if (layerStrings.length === 0) {
      return undefined;
    }

    // Parse each layer
    const layers: T[] = [];
    for (const layerStr of layerStrings) {
      const parsedLayer = parseSingleLayer(layerStr);
      if (!parsedLayer) {
        return undefined; // Parsing failed for this layer
      }
      layers.push(parsedLayer);
    }

    return layers;
  } catch (_error) {
    // If parsing fails, return undefined to indicate invalid input
    return undefined;
  }
}

/**
 * Collects all child nodes from a css-tree AST Value node.
 * Common pattern across all multi-layer parsers.
 *
 * @param ast - css-tree AST (must contain Value nodes)
 * @returns Flattened array of child nodes
 */
export function collectCssTreeChildren(ast: unknown): unknown[] {
  const children: unknown[] = [];

  // Type guard to ensure we have a valid css-tree node
  if (!ast || typeof ast !== "object") {
    return children;
  }

  // Walk the AST and collect children from Value nodes
  const csstree = require("css-tree");
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: { children?: Iterable<unknown> }) => {
      if (node.children) {
        for (const child of node.children) {
          children.push(child);
        }
      }
    },
  });

  return children;
}


=== File: src/list-style.ts ===
// b_path:: src/list-style.ts
import { cssUrlRegex } from "./color-utils";
import { sortProperties } from "./index";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const POSITION = /^(inside|outside)$/i;
const IMAGE = new RegExp(`^(${cssUrlRegex().source})$`, "i");
const COMMON_TYPE =
  /^(disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman|lower-greek|lower-alpha|lower-latin|upper-alpha|upper-latin|armenian|georgian|none)$/i;
const IDENT = /^[-_a-zA-Z][-_a-zA-Z0-9]*$/;
const STRING_VALUE = /^["'].*["']$/;

export default function listStyle(value: string): Record<string, string> | undefined {
  const normalizedValue = normalizeColor(value);

  // Special case: "none" alone sets both type and image to none, position to default
  if (normalizedValue === "none") {
    return sortProperties({
      "list-style-type": "none",
      "list-style-position": "outside",
      "list-style-image": "none",
    });
  }

  const values = normalizedValue.split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return sortProperties({
      "list-style-type": values[0],
      "list-style-position": values[0],
      "list-style-image": values[0],
    });
  }

  // Start with defaults - list-style shorthand resets all properties
  const result: Record<string, string> = {
    "list-style-type": "disc",
    "list-style-position": "outside",
    "list-style-image": "none",
  };

  // Track what was explicitly set to detect duplicates
  const explicitlySet = {
    type: false,
    position: false,
    image: false,
  };

  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (POSITION.test(v)) {
      if (explicitlySet.position) return;
      result["list-style-position"] = v;
      explicitlySet.position = true;
    } else if (IMAGE.test(v)) {
      if (explicitlySet.image) return;
      result["list-style-image"] = v;
      explicitlySet.image = true;
    } else if (COMMON_TYPE.test(v)) {
      if (explicitlySet.type) return;
      result["list-style-type"] = v;
      explicitlySet.type = true;
    } else {
      // Custom counter-style identifier or string value
      if (IDENT.test(v) || STRING_VALUE.test(v)) {
        if (explicitlySet.type) return;
        result["list-style-type"] = v;
        explicitlySet.type = true;
      } else {
        return;
      }
    }
  }

  return sortProperties(result);
}


=== File: src/mask-layers.ts ===
// b_path:: src/mask-layers.ts

import * as csstree from "css-tree";
import { hasTopLevelCommas, parseLayersGeneric } from "./layer-parser-utils";
import type { MaskLayer, MaskResult } from "./schema";

// CSS default values for mask properties
export const MASK_DEFAULTS = {
  image: "none",
  mode: "match-source",
  position: "0% 0%",
  size: "auto",
  repeat: "repeat",
  origin: "border-box",
  clip: "border-box",
  composite: "add",
} as const;

/**
 * Detects if a mask value needs advanced parsing (multi-layer masks)
 */
export function needsAdvancedParser(value: string): boolean {
  return hasTopLevelCommas(value);
}

/**
 * Parses a complex mask value using css-tree AST parsing
 */
export function parseMaskLayers(value: string): MaskResult | undefined {
  const layers = parseLayersGeneric(value, parseSingleLayer);
  return layers ? { layers } : undefined;
}

/**
 * Parses a single mask layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): MaskLayer | undefined {
  return parseSingleLayerWithCssTree(layerValue);
}

/**
 * Parses a single mask layer using css-tree AST parsing
 */
function parseSingleLayerWithCssTree(layerValue: string): MaskLayer | undefined {
  const result: MaskLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling position/size parsing
  const isValid = processCssChildren(children, result);

  // Return undefined if there were unrecognized tokens (stricter error handling)
  return isValid ? result : undefined;
}

/**
 * Processes CSS AST children sequentially to extract mask properties
 *
 * This function handles the complex parsing of CSS mask layer syntax,
 * including position/size combinations separated by "/", various keyword types,
 * and proper ordering according to CSS specifications.
 */
function processCssChildren(children: csstree.CssNode[], result: MaskLayer): boolean {
  let i = 0;
  let hasPositionSize = false;
  let hasUnrecognizedToken = false;

  while (i < children.length) {
    const child = children[i];

    // Skip whitespace and operators (except "/")
    if (child.type === "WhiteSpace") {
      i++;
      continue;
    }

    if (child.type === "Operator" && (child as csstree.Operator).value !== "/") {
      i++;
      continue;
    }

    // Handle mask-image (url(), none, or image functions like gradients)
    if (child.type === "Url" && !result.image) {
      result.image = `url(${(child as csstree.Url).value})`;
      i++;
      continue;
    }

    if (child.type === "Function") {
      const funcNode = child as csstree.FunctionNode;
      if (
        [
          "linear-gradient",
          "radial-gradient",
          "conic-gradient",
          "repeating-linear-gradient",
          "repeating-radial-gradient",
          "repeating-conic-gradient",
          "image",
          "image-set",
          "cross-fade",
          "paint",
          "element",
        ].includes(funcNode.name)
      ) {
        if (!result.image) {
          result.image = csstree.generate(child);
        }
        i++;
        continue;
      }
    }

    if (
      child.type === "Identifier" &&
      (child as csstree.Identifier).name === "none" &&
      !result.image
    ) {
      result.image = "none";
      i++;
      continue;
    }

    // Handle position and size (complex parsing needed)
    if (
      !hasPositionSize &&
      ((child.type === "Operator" && (child as csstree.Operator).value === "/") ||
        (child.type === "Identifier" &&
          ["left", "center", "right", "top", "bottom"].includes(
            (child as csstree.Identifier).name
          )) ||
        child.type === "Dimension" ||
        child.type === "Percentage" ||
        child.type === "Number")
    ) {
      const positionParts: string[] = [];
      const sizeParts: string[] = [];
      let _hasSlash = false;

      // Check if we start with "/"
      if (child.type === "Operator" && (child as csstree.Operator).value === "/") {
        _hasSlash = true;
        i++; // skip "/"

        // Collect size parts
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }
          if (
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Identifier" &&
              ["auto", "cover", "contain"].includes((currentChild as csstree.Identifier).name)) ||
            (currentChild.type === "Function" &&
              ["calc", "min", "max", "clamp", "var"].includes(
                (currentChild as csstree.FunctionNode).name
              ))
          ) {
            sizeParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      } else {
        // Collect position parts until we hit "/" or a non-position node
        while (i < children.length) {
          const currentChild = children[i];
          if (currentChild.type === "WhiteSpace") {
            i++;
            continue;
          }

          if (
            currentChild.type === "Operator" &&
            (currentChild as csstree.Operator).value === "/"
          ) {
            _hasSlash = true;
            i++; // skip "/"

            // Collect size parts
            while (i < children.length) {
              const sizeChild = children[i];
              if (sizeChild.type === "WhiteSpace") {
                i++;
                continue;
              }
              if (
                sizeChild.type === "Dimension" ||
                sizeChild.type === "Percentage" ||
                sizeChild.type === "Number" ||
                (sizeChild.type === "Identifier" &&
                  ["auto", "cover", "contain"].includes((sizeChild as csstree.Identifier).name)) ||
                (sizeChild.type === "Function" &&
                  ["calc", "min", "max", "clamp", "var"].includes(
                    (sizeChild as csstree.FunctionNode).name
                  ))
              ) {
                sizeParts.push(csstree.generate(sizeChild));
                i++;
              } else {
                break;
              }
            }
            break;
          } else if (
            (currentChild.type === "Identifier" &&
              ["left", "center", "right", "top", "bottom"].includes(
                (currentChild as csstree.Identifier).name
              )) ||
            currentChild.type === "Dimension" ||
            currentChild.type === "Percentage" ||
            currentChild.type === "Number" ||
            (currentChild.type === "Function" &&
              ["calc", "min", "max", "clamp", "var"].includes(
                (currentChild as csstree.FunctionNode).name
              ))
          ) {
            positionParts.push(csstree.generate(currentChild));
            i++;
          } else {
            break;
          }
        }
      }

      if (positionParts.length > 0) {
        result.position = positionParts.join(" ");
      }
      if (sizeParts.length > 0) {
        result.size = sizeParts.join(" ");
      }

      hasPositionSize = true;
      continue;
    }

    // Handle repeat values
    // Note: repeat-x and repeat-y are supported for compatibility with background-repeat,
    // even though the mask-repeat spec technically only allows [repeat|no-repeat|round|space]{1,2}
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(name)) {
        if (!result.repeat) {
          let repeat = name;
          i++;

          // Check for second repeat value
          if (i < children.length && children[i].type === "Identifier") {
            const nextName = (children[i] as csstree.Identifier).name;
            if (
              ["repeat", "repeat-x", "repeat-y", "space", "round", "no-repeat"].includes(nextName)
            ) {
              repeat += ` ${nextName}`;
              i++;
            }
          }

          result.repeat = repeat;
        } else {
          i++;
        }
        continue;
      }
    }

    // Handle mode keywords
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["alpha", "luminance", "match-source"].includes(name)) {
        if (!result.mode) {
          result.mode = name;
        }
        i++;
        continue;
      }
    }

    // Handle composite keywords
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (["add", "subtract", "intersect", "exclude"].includes(name)) {
        if (!result.composite) {
          result.composite = name;
        }
        i++;
        continue;
      }
    }

    // Handle geometry-box values (origin/clip)
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (
        ["border-box", "padding-box", "content-box", "fill-box", "stroke-box", "view-box"].includes(
          name
        )
      ) {
        if (!result.origin) {
          result.origin = name;
        } else if (!result.clip) {
          result.clip = name;
        }
        i++;
        continue;
      }
    }

    // Handle "no-clip" keyword for mask-clip
    if (child.type === "Identifier") {
      const name = (child as csstree.Identifier).name;
      if (name === "no-clip") {
        if (!result.clip) {
          result.clip = "border-box"; // no-clip maps to border-box per CSS spec
        }
        i++;
        continue;
      }
    }

    // Skip unrecognized nodes - mark as having unrecognized token for stricter error handling
    hasUnrecognizedToken = true;
    i++;
  }

  // Special handling for origin/clip: if a layer specifies only one box value,
  // it applies to both origin and clip (CSS Masking spec behavior)
  if (result.origin !== undefined && result.clip === undefined) {
    result.clip = MASK_DEFAULTS.clip; // Default to border-box, not origin value
  }

  return !hasUnrecognizedToken;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: MaskLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "mask-image": layers.map((l) => l.image || MASK_DEFAULTS.image),
    "mask-mode": layers.map((l) => l.mode || MASK_DEFAULTS.mode),
    "mask-position": layers.map((l) => l.position || MASK_DEFAULTS.position),
    "mask-size": layers.map((l) => l.size || MASK_DEFAULTS.size),
    "mask-repeat": layers.map((l) => l.repeat || MASK_DEFAULTS.repeat),
    "mask-origin": layers.map((l) => l.origin || MASK_DEFAULTS.origin),
    "mask-clip": layers.map((l) => l.clip || MASK_DEFAULTS.clip),
    "mask-composite": layers.map((l) => l.composite || MASK_DEFAULTS.composite),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/mask.ts ===
// b_path:: src/mask.ts

import { needsAdvancedParser, parseMaskLayers, reconstructLayers } from "./mask-layers";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function mask(value: string): Record<string, string> | undefined {
  // Trim the input value
  const trimmedValue = value.trim();

  // Handle global keywords first
  if (KEYWORD.test(trimmedValue)) {
    return {
      "mask-image": trimmedValue,
      "mask-mode": trimmedValue,
      "mask-position": trimmedValue,
      "mask-size": trimmedValue,
      "mask-repeat": trimmedValue,
      "mask-origin": trimmedValue,
      "mask-clip": trimmedValue,
      "mask-composite": trimmedValue,
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(trimmedValue)) {
    const result = parseMaskLayers(trimmedValue);
    if (result) {
      return reconstructLayers(result.layers);
    }
    return undefined;
  }

  // For single-layer cases, use the advanced parser as well
  // since mask syntax is complex and the parser handles it well
  const result = parseMaskLayers(trimmedValue);
  if (result) {
    return reconstructLayers(result.layers);
  }

  return undefined;
}


=== File: src/normalize-color.ts ===
// b_path:: src/normalize-color.ts
import { hslaRegex, hslRegex, rgbaRegex, rgbRegex } from "./color-utils";

const FUNCTIONS = [hslaRegex(), hslRegex(), rgbRegex(), rgbaRegex()];

export default function normalizeColor(value: string): string {
  return FUNCTIONS.reduce(
    (acc: string, func: RegExp) => acc.replace(func, (match: string) => match.replace(/\s+/g, "")),
    value
  );
}


=== File: src/offset.ts ===
// b_path:: src/offset.ts
import isAngle from "./is-angle.js";
import isLength from "./is-length.js";

function splitTopLevelSlash(input: string): [string, string?] | null {
  let depth = 0;
  let inQuotes = false;
  let quoteChar = "";
  let slashIndex = -1;

  for (let i = 0; i < input.length; i++) {
    const char = input[i];

    if (!inQuotes && (char === '"' || char === "'")) {
      inQuotes = true;
      quoteChar = char;
    } else if (inQuotes && char === quoteChar) {
      inQuotes = false;
      quoteChar = "";
    } else if (!inQuotes) {
      if (char === "(") {
        depth++;
      } else if (char === ")") {
        depth--;
      } else if (char === "/" && depth === 0) {
        if (slashIndex !== -1) {
          // More than one top-level slash
          return null;
        }
        slashIndex = i;
      }
    }
  }

  if (slashIndex === -1) {
    return [input.trim()];
  }

  const main = input.slice(0, slashIndex).trim();
  const anchor = input.slice(slashIndex + 1).trim();
  return [main, anchor];
}

function tokenizeRespectingFunctions(input: string): string[] {
  const tokens: string[] = [];
  let current = "";
  let depth = 0;
  let inQuotes = false;
  let quoteChar = "";

  for (let i = 0; i < input.length; i++) {
    const char = input[i];

    if (!inQuotes && (char === '"' || char === "'")) {
      inQuotes = true;
      quoteChar = char;
      current += char;
    } else if (inQuotes && char === quoteChar) {
      inQuotes = false;
      quoteChar = "";
      current += char;
    } else if (!inQuotes) {
      if (char === "(") {
        depth++;
        current += char;
      } else if (char === ")") {
        depth--;
        current += char;
      } else if (char === " " && depth === 0) {
        if (current.trim()) {
          tokens.push(current.trim());
          current = "";
        }
      } else {
        current += char;
      }
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    tokens.push(current.trim());
  }

  return tokens;
}

function isPositionKeyword(token: string): boolean {
  return /^(auto|normal|left|right|top|bottom|center)$/i.test(token);
}

function parsePosition(tokens: string[]): { position: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  // Two tokens: x y (check first to avoid ambiguity)
  if (tokens.length >= 2) {
    const first = tokens[0];
    const second = tokens[1];
    if (
      (isPositionKeyword(first) || isLength(first)) &&
      (isPositionKeyword(second) || isLength(second))
    ) {
      return { position: `${first} ${second}`, consumed: 2 };
    }
  }

  // auto or normal
  if (tokens[0] === "auto" || tokens[0] === "normal") {
    return { position: tokens[0], consumed: 1 };
  }

  // Single keyword
  if (isPositionKeyword(tokens[0])) {
    return { position: tokens[0], consumed: 1 };
  }

  // Single length/% (horizontal center)
  if (isLength(tokens[0])) {
    return { position: tokens[0], consumed: 1 };
  }

  return null;
}

function parsePath(tokens: string[]): { path: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  const token = tokens[0];

  if (token === "none") {
    return { path: "none", consumed: 1 };
  }

  if (token.startsWith("path(") || token.startsWith("ray(") || token.startsWith("url(")) {
    return { path: token, consumed: 1 };
  }

  return null;
}

function parseDistance(tokens: string[]): { distance: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  if (isLength(tokens[0])) {
    return { distance: tokens[0], consumed: 1 };
  }

  return null;
}

function parseRotate(tokens: string[]): { rotate: string; consumed: number } | null {
  if (tokens.length === 0) return null;

  // Check for compound forms first: auto <angle> or reverse <angle> or <angle> auto/reverse
  if (tokens.length >= 2) {
    const first = tokens[0];
    const second = tokens[1];

    if ((first === "auto" || first === "reverse") && isAngle(second)) {
      return { rotate: `${first} ${second}`, consumed: 2 };
    }
    if (isAngle(first) && (second === "auto" || second === "reverse")) {
      return { rotate: `${second} ${first}`, consumed: 2 };
    }
  }

  // Single tokens
  const token = tokens[0];

  if (token === "auto" || token === "reverse") {
    return { rotate: token, consumed: 1 };
  }

  if (isAngle(token)) {
    return { rotate: token, consumed: 1 };
  }

  return null;
}

function parseAnchor(anchor: string): string | null {
  if (!anchor) return null;

  const tokens = tokenizeRespectingFunctions(anchor);

  if (tokens.length === 1) {
    if (tokens[0] === "auto" || isPositionKeyword(tokens[0])) {
      return tokens[0];
    }
  }

  if (tokens.length === 2) {
    if (
      (isPositionKeyword(tokens[0]) || isLength(tokens[0])) &&
      (isPositionKeyword(tokens[1]) || isLength(tokens[1]))
    ) {
      return `${tokens[0]} ${tokens[1]}`;
    }
  }

  return null;
}

export default (value: string): Record<string, string> | undefined => {
  // Handle global keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "offset-position": value,
      "offset-path": value,
      "offset-distance": value,
      "offset-rotate": value,
      "offset-anchor": value,
    };
  }

  // Split on top-level slash
  const slashSplit = splitTopLevelSlash(value);
  if (!slashSplit) return undefined; // Invalid: multiple slashes

  const [main, anchor] = slashSplit;

  // Tokenize main part
  const tokens = tokenizeRespectingFunctions(main);
  if (tokens.length === 0) return undefined;

  const result: Record<string, string> = {};

  let index = 0;

  // Try to parse position first
  const positionResult = parsePosition(tokens.slice(index));
  if (positionResult) {
    result["offset-position"] = positionResult.position;
    index += positionResult.consumed;
  }

  // Try to parse path
  const pathResult = parsePath(tokens.slice(index));
  if (pathResult) {
    result["offset-path"] = pathResult.path;
    index += pathResult.consumed;
  } else {
    // Path is required unless we have position only
    if (index === 0) return undefined;
  }

  // Try to parse distance
  const distanceResult = parseDistance(tokens.slice(index));
  if (distanceResult) {
    result["offset-distance"] = distanceResult.distance;
    index += distanceResult.consumed;
  }

  // Try to parse rotate
  const rotateResult = parseRotate(tokens.slice(index));
  if (rotateResult) {
    result["offset-rotate"] = rotateResult.rotate;
    index += rotateResult.consumed;
  }

  // Check if all tokens consumed
  if (index !== tokens.length) return undefined;

  // Parse anchor if present
  if (anchor) {
    const parsedAnchor = parseAnchor(anchor);
    if (parsedAnchor === null) return undefined;
    result["offset-anchor"] = parsedAnchor;
  }

  return result;
};


=== File: src/outline.ts ===
// b_path:: src/outline.ts
import { sortProperties } from "./index";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const WIDTH = /^(thin|medium|thick)$/;
const STYLE = /^(none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset)$/i;
const KEYWORD = /^(inherit|initial|unset|revert)$/i;

export default function outline(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length > 3) return;
  if (values.length === 1 && KEYWORD.test(values[0])) {
    return sortProperties({
      "outline-width": values[0],
      "outline-style": values[0],
      "outline-color": values[0],
    });
  }

  const parsed: { width?: string; style?: string; color?: string } = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (isLength(v) || WIDTH.test(v)) {
      if (parsed.width) return;
      parsed.width = v;
    } else if (STYLE.test(v)) {
      if (parsed.style) return;
      parsed.style = v;
    } else if (isColor(v)) {
      if (parsed.color) return;
      parsed.color = v;
    } else {
      return;
    }
  }

  // Use defaults for missing properties
  // Per CSS spec, the default values for outline shorthand are:
  //   width: 'medium', style: 'none', color: 'currentcolor'
  // See: https://drafts.csswg.org/css-ui-4/#propdef-outline
  return sortProperties({
    "outline-width": parsed.width || "medium",
    "outline-style": parsed.style || "none",
    "outline-color": parsed.color || "currentcolor",
  });
}


=== File: src/overflow.ts ===
// b_path:: src/overflow.ts
export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "overflow-x": value,
      "overflow-y": value,
    };
  }

  // Split values on whitespace
  const values = value.trim().split(/\s+/);

  // Validate value count - max 2 values
  if (values.length > 2) {
    return undefined;
  }

  // Valid overflow values
  const validValues = /^(visible|hidden|clip|scroll|auto)$/i;

  // Handle single value - both x and y get the same value
  if (values.length === 1) {
    if (!validValues.test(values[0])) {
      return undefined;
    }
    return {
      "overflow-x": values[0],
      "overflow-y": values[0],
    };
  }

  // Handle two values - first=x, second=y
  if (values.length === 2) {
    if (!validValues.test(values[0]) || !validValues.test(values[1])) {
      return undefined;
    }
    return {
      "overflow-x": values[0],
      "overflow-y": values[1],
    };
  }

  return undefined;
};


=== File: src/place-content.ts ===
// b_path:: src/place-content.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-content": value,
      "justify-content": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Validate processed values
  const validValuePattern =
    /^(normal|space-between|space-around|space-evenly|stretch|center|start|end|flex-start|flex-end|baseline|first baseline|last baseline|safe center|safe start|safe end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe flex-start|unsafe flex-end)$/i;

  for (const val of processedValues) {
    if (!validValuePattern.test(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value
  if (processedValues.length === 1) {
    return {
      "align-content": processedValues[0],
      "justify-content": processedValues[0],
    };
  }

  // Handle two values - first=align-content, second=justify-content
  if (processedValues.length === 2) {
    return {
      "align-content": processedValues[0],
      "justify-content": processedValues[1],
    };
  }

  return undefined;
};


=== File: src/place-items.ts ===
// b_path:: src/place-items.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-items": value,
      "justify-items": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|self-start|self-end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Helper functions for validation
  const isValidAlignItemsValue = (val: string): boolean => {
    return /^(normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  const isValidJustifyItemsValue = (val: string): boolean => {
    return /^(normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|left|right|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  // Validate processed values
  for (const val of processedValues) {
    if (!isValidAlignItemsValue(val) && !isValidJustifyItemsValue(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value, but left/right are invalid for single value
  if (processedValues.length === 1) {
    const val = processedValues[0];
    if (val === "left" || val === "right") {
      return undefined; // Cannot apply left/right to both properties
    }
    if (!isValidAlignItemsValue(val)) {
      return undefined;
    }
    return {
      "align-items": val,
      "justify-items": val,
    };
  }

  // Handle two values - first=align-items, second=justify-items
  if (processedValues.length === 2) {
    const [alignVal, justifyVal] = processedValues;
    if (!isValidAlignItemsValue(alignVal) || alignVal === "left" || alignVal === "right") {
      return undefined; // left/right cannot be used for align-items
    }
    if (!isValidJustifyItemsValue(justifyVal)) {
      return undefined;
    }
    return {
      "align-items": alignVal,
      "justify-items": justifyVal,
    };
  }

  return undefined;
};


=== File: src/place-self.ts ===
// b_path:: src/place-self.ts
import { consolidatePlaceTokens } from "./place-utils";

export default (value: string): Record<string, string> | undefined => {
  // Handle global CSS keywords
  if (/^(inherit|initial|unset|revert)$/i.test(value)) {
    return {
      "align-self": value,
      "justify-self": value,
    };
  }

  // Process tokens with lookahead for compound keywords
  const processedValues = consolidatePlaceTokens(
    value,
    /^(center|start|end|self-start|self-end|flex-start|flex-end)$/i
  );
  if (!processedValues) {
    return undefined;
  }

  // Helper functions for validation
  const isValidAlignSelfValue = (val: string): boolean => {
    return /^(auto|normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|anchor-center|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  const isValidJustifySelfValue = (val: string): boolean => {
    return /^(auto|normal|stretch|center|start|end|self-start|self-end|flex-start|flex-end|baseline|first baseline|last baseline|left|right|safe center|safe start|safe end|safe self-start|safe self-end|safe flex-start|safe flex-end|unsafe center|unsafe start|unsafe end|unsafe self-start|unsafe self-end|unsafe flex-start|unsafe flex-end)$/i.test(
      val
    );
  };

  // Validate processed values
  for (const val of processedValues) {
    if (!isValidAlignSelfValue(val) && !isValidJustifySelfValue(val)) {
      return undefined;
    }
  }

  // Handle single value - both properties get the same value, but left/right are invalid for single value
  if (processedValues.length === 1) {
    const val = processedValues[0];
    if (val === "left" || val === "right") {
      return undefined; // Cannot apply left/right to both properties
    }
    if (!isValidAlignSelfValue(val)) {
      return undefined;
    }
    return {
      "align-self": val,
      "justify-self": val,
    };
  }

  // Handle two values - first=align-self, second=justify-self
  if (processedValues.length === 2) {
    const [alignVal, justifyVal] = processedValues;
    if (!isValidAlignSelfValue(alignVal) || alignVal === "left" || alignVal === "right") {
      return undefined; // left/right cannot be used for align-self
    }
    if (!isValidJustifySelfValue(justifyVal)) {
      return undefined;
    }
    return {
      "align-self": alignVal,
      "justify-self": justifyVal,
    };
  }

  return undefined;
};


=== File: src/place-utils.ts ===
// b_path:: src/place-utils.ts
export function consolidatePlaceTokens(
  value: string,
  nextTokenPattern: RegExp
): string[] | undefined {
  const tokens = value.trim().split(/\s+/);
  const out: string[] = [];
  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];
    if (/^(first|last)$/i.test(t) && i + 1 < tokens.length && /^baseline$/i.test(tokens[i + 1])) {
      out.push(`${tokens[i]} ${tokens[i + 1]}`);
      i++;
      continue;
    }
    if (
      /^(safe|unsafe)$/i.test(t) &&
      i + 1 < tokens.length &&
      nextTokenPattern.test(tokens[i + 1])
    ) {
      out.push(`${tokens[i]} ${tokens[i + 1]}`);
      i++;
      continue;
    }
    out.push(t);
  }
  return out.length <= 2 ? out : undefined;
}


=== File: src/schema.ts ===
// b_path:: src/schema.ts
import { z } from "zod";

/**
 * Base CSS value schemas
 */
export const CssValueSchema = z.string().describe("CSS property value");
export const CssPropertySchema = z.string().describe("CSS property name");
export const CssDeclarationSchema = z.string().describe("CSS declaration string");

/**
 * Output format enum schema
 * - 'css': Returns kebab-case CSS string (e.g., "margin-top: 10px;")
 * - 'js': Returns camelCase JavaScript object (e.g., { marginTop: '10px' })
 */
export const FormatEnumSchema = z.enum(["css", "js"]);

/**
 * Property grouping strategy enum schema
 * - 'by-property': Groups by property type (e.g., all margins, then all borders)
 * - 'by-side': Groups by directional side (e.g., all top properties, then all right properties)
 */
export const PropertyGroupingEnumSchema = z.enum(["by-property", "by-side"]);

// Derive enum arrays from schemas for runtime use
export const FORMAT_VALUES = FormatEnumSchema.options;
export const PROPERTY_GROUPING_VALUES = PropertyGroupingEnumSchema.options;

// Named constants for better readability (derived directly from schema)
export const FORMAT_CSS = "css" as const;
export const FORMAT_JS = "js" as const;
export const GROUPING_BY_PROPERTY = "by-property" as const;
export const GROUPING_BY_SIDE = "by-side" as const;

/**
 * Options schema for CSS shorthand expansion
 */
export const ExpandOptionsSchema = z
  .object({
    format: FormatEnumSchema.default("css").describe("Output format"),
    indent: z.number().min(0).default(0).describe("Indentation for CSS output"),
    separator: z.string().default("\n").describe("Separator between CSS declarations"),
    propertyGrouping: PropertyGroupingEnumSchema.default("by-property").describe(
      "Property grouping strategy: 'by-property' groups by property type (e.g., all margins, then all borders), 'by-side' groups by directional side (e.g., all top properties, then all right properties)"
    ),
    expandPartialLonghand: z
      .boolean()
      .default(false)
      .describe(
        "Expand partial directional longhand properties (e.g., margin-top) by filling in missing sides with CSS default values"
      ),
  })
  .describe("Options for CSS expansion");

/**
 * CSS Tree and custom warning types for validation
 */
export const CssTreeSyntaxParseErrorSchema = z
  .object({
    name: z.string(),
    message: z.string(),
    line: z.number(),
    column: z.number(),
    property: z.string().optional(),
    offset: z.number().optional(),
    length: z.number().optional(),
  })
  .describe("CSS Tree syntax parsing error");

export const BStyleWarningSchema = z
  .object({
    property: z.string().describe("CSS property that has the warning"),
    name: z.string().describe("Warning name/type"),
    syntax: z.string().optional().describe("CSS syntax that caused the warning"),
    formattedWarning: z.string().optional().describe("Formatted warning message for display"),
  })
  .describe("Custom warning for CSS property validation");

/**
 * Background layer schema for multi-layer background parsing
 */
export const BackgroundLayerSchema = z
  .object({
    image: z.string().optional().describe("Background image (url, gradient, or none)"),
    position: z.string().optional().describe("Background position (e.g., '10px 20px')"),
    size: z.string().optional().describe("Background size (e.g., 'cover', '100px 200px')"),
    repeat: z.string().optional().describe("Background repeat (e.g., 'no-repeat', 'repeat-x')"),
    attachment: z.string().optional().describe("Background attachment (e.g., 'fixed', 'scroll')"),
    origin: z.string().optional().describe("Background origin (e.g., 'padding-box', 'border-box')"),
    clip: z.string().optional().describe("Background clip (e.g., 'padding-box', 'border-box')"),
  })
  .describe("Single layer in a multi-layer background");

/**
 * Multi-layer background parsing result
 */
export const BackgroundResultSchema = z
  .object({
    layers: z.array(BackgroundLayerSchema).describe("Array of background layers"),
    color: z.string().optional().describe("Global background color applied to all layers"),
  })
  .describe("Result of parsing multi-layer background declaration");

/**
 * Mask layer schema for multi-layer mask parsing
 */
export const MaskLayerSchema = z
  .object({
    image: z.string().optional().describe("Mask image (url, gradient, or none)"),
    mode: z
      .string()
      .optional()
      .describe("Masking mode (e.g., 'alpha', 'luminance', 'match-source')"),
    position: z.string().optional().describe("Mask position (e.g., '10px 20px', 'center')"),
    size: z.string().optional().describe("Mask size (e.g., 'cover', '100px 200px', 'auto')"),
    repeat: z.string().optional().describe("Mask repeat (e.g., 'no-repeat', 'repeat-x')"),
    origin: z
      .string()
      .optional()
      .describe("Mask origin (e.g., 'padding-box', 'border-box', 'content-box')"),
    clip: z
      .string()
      .optional()
      .describe("Mask clip (e.g., 'padding-box', 'border-box', 'content-box', 'no-clip')"),
    composite: z
      .string()
      .optional()
      .describe("Mask composite (e.g., 'add', 'subtract', 'intersect', 'exclude')"),
  })
  .describe("Single layer in a multi-layer mask");

/**
 * Multi-layer mask parsing result
 */
export const MaskResultSchema = z
  .object({
    layers: z.array(MaskLayerSchema).describe("Array of mask layers"),
  })
  .describe("Result of parsing multi-layer mask declaration");

/**
 * Transition layer schema for multi-layer transition parsing
 */
export const TransitionLayerSchema = z
  .object({
    property: z
      .string()
      .optional()
      .describe("Transition property (e.g., 'opacity', 'all', 'transform')"),
    duration: z.string().optional().describe("Transition duration (e.g., '300ms', '0.5s')"),
    timingFunction: z
      .string()
      .optional()
      .describe("Transition timing function (e.g., 'ease', 'cubic-bezier(0.4, 0, 0.2, 1)')"),
    delay: z.string().optional().describe("Transition delay (e.g., '100ms', '0s')"),
  })
  .describe("Single layer in a multi-layer transition");

/**
 * Multi-layer transition parsing result
 */
export const TransitionResultSchema = z
  .object({
    layers: z.array(TransitionLayerSchema).describe("Array of transition layers"),
  })
  .describe("Result of parsing multi-layer transition declaration");

/**
 * Animation layer schema for multi-layer animation parsing
 */
export const AnimationLayerSchema = z
  .object({
    name: z.string().optional().describe("Animation name (e.g., 'spin', 'none')"),
    duration: z.string().optional().describe("Animation duration (e.g., '1s', '300ms')"),
    timingFunction: z
      .string()
      .optional()
      .describe("Animation timing function (e.g., 'ease', 'cubic-bezier(0.4, 0, 0.2, 1)')"),
    delay: z.string().optional().describe("Animation delay (e.g., '100ms', '0s')"),
    iterationCount: z
      .string()
      .optional()
      .describe("Animation iteration count (e.g., '3', 'infinite')"),
    direction: z
      .string()
      .optional()
      .describe(
        "Animation direction (e.g., 'normal', 'reverse', 'alternate', 'alternate-reverse')"
      ),
    fillMode: z
      .string()
      .optional()
      .describe("Animation fill mode (e.g., 'none', 'forwards', 'backwards', 'both')"),
    playState: z.string().optional().describe("Animation play state (e.g., 'running', 'paused')"),
  })
  .describe("Single layer in a multi-layer animation");

/**
 * Multi-layer animation parsing result
 */
export const AnimationResultSchema = z
  .object({
    layers: z.array(AnimationLayerSchema).describe("Array of animation layers"),
  })
  .describe("Result of parsing multi-layer animation declaration");

/**
 * Main expansion result schema
 */
export const ExpandResultSchema = z
  .object({
    ok: z.boolean().describe("Whether expansion was successful (no syntax errors)"),
    result: z
      .union([
        z
          .record(z.string(), z.string())
          .describe(
            "JavaScript object format result (multiple declarations are merged, with later properties overriding earlier ones)"
          ),
        z.string().describe("CSS string format result (multiple declarations are joined)"),
        z.undefined().describe("No result when input is empty or invalid"),
      ])
      .describe("The expanded CSS result"),
    issues: z
      .array(z.union([CssTreeSyntaxParseErrorSchema, BStyleWarningSchema]))
      .describe("Array of syntax errors and validation warnings"),
  })
  .describe("Result of CSS shorthand expansion");

/**
 * Stylesheet validation result schema
 */
export const StylesheetValidationSchema = z
  .object({
    ok: z.boolean().describe("Whether validation passed (no errors)"),
    errors: z.array(CssTreeSyntaxParseErrorSchema).describe("Array of syntax parsing errors"),
    warnings: z.array(BStyleWarningSchema).describe("Array of property validation warnings"),
  })
  .describe("Result of CSS stylesheet validation");

// Derived TypeScript types from schemas
export type Format = z.infer<typeof FormatEnumSchema>;
export type PropertyGrouping = z.infer<typeof PropertyGroupingEnumSchema>;
export type ExpandOptions = z.infer<typeof ExpandOptionsSchema>;
export type ExpandResult = z.infer<typeof ExpandResultSchema>;
export type BackgroundLayer = z.infer<typeof BackgroundLayerSchema>;
export type BackgroundResult = z.infer<typeof BackgroundResultSchema>;
export type MaskLayer = z.infer<typeof MaskLayerSchema>;
export type MaskResult = z.infer<typeof MaskResultSchema>;
export type TransitionLayer = z.infer<typeof TransitionLayerSchema>;
export type TransitionResult = z.infer<typeof TransitionResultSchema>;
export type AnimationLayer = z.infer<typeof AnimationLayerSchema>;
export type AnimationResult = z.infer<typeof AnimationResultSchema>;
export type BStyleWarning = z.infer<typeof BStyleWarningSchema>;
export type StylesheetValidation = z.infer<typeof StylesheetValidationSchema>;
export type CssValue = z.infer<typeof CssValueSchema>;
export type CssProperty = z.infer<typeof CssPropertySchema>;
export type CssDeclaration = z.infer<typeof CssDeclarationSchema>;

// Export schemas for runtime validation
export const schemas = {
  Format: FormatEnumSchema,
  PropertyGrouping: PropertyGroupingEnumSchema,
  ExpandOptions: ExpandOptionsSchema,
  ExpandResult: ExpandResultSchema,
  BackgroundLayer: BackgroundLayerSchema,
  BackgroundResult: BackgroundResultSchema,
  MaskLayer: MaskLayerSchema,
  MaskResult: MaskResultSchema,
  TransitionLayer: TransitionLayerSchema,
  TransitionResult: TransitionResultSchema,
  AnimationLayer: AnimationLayerSchema,
  AnimationResult: AnimationResultSchema,
  BStyleWarning: BStyleWarningSchema,
  StylesheetValidation: StylesheetValidationSchema,
  CssValue: CssValueSchema,
  CssProperty: CssPropertySchema,
  CssDeclaration: CssDeclarationSchema,
} as const;


=== File: src/text-decoration.ts ===
// b_path:: src/text-decoration.ts
import { sortProperties } from "./index";
import isColor from "./is-color";
import isLength from "./is-length";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const LINE = /^(none|underline|overline|line-through|blink|spelling-error|grammar-error)$/i;
const STYLE = /^(solid|double|dotted|dashed|wavy)$/i;
const THICKNESS = /^(auto|from-font)$/i;

export default function textDecoration(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return sortProperties({
      "text-decoration-line": values[0],
      "text-decoration-style": values[0],
      "text-decoration-color": values[0],
      "text-decoration-thickness": values[0],
    });
  }

  // Initialize with defaults - text-decoration shorthand resets all properties
  const result: Record<string, string> = {
    "text-decoration-line": "none",
    "text-decoration-style": "solid",
    "text-decoration-color": "currentColor",
    "text-decoration-thickness": "auto",
  };

  const lines: string[] = [];
  let hasStyle = false;
  let hasColor = false;
  let hasThickness = false;

  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (LINE.test(v)) {
      lines.push(v);
    } else if (STYLE.test(v)) {
      if (hasStyle) return; // Duplicate style
      result["text-decoration-style"] = v;
      hasStyle = true;
    } else if (isColor(v)) {
      if (hasColor) return; // Duplicate color
      result["text-decoration-color"] = v;
      hasColor = true;
    } else if (THICKNESS.test(v) || isLength(v)) {
      if (hasThickness) return; // Duplicate thickness
      result["text-decoration-thickness"] = v;
      hasThickness = true;
    } else {
      return;
    }
  }

  if (lines.length > 1 && lines.includes("none")) return;

  if (lines.length > 0) {
    if (lines.length !== new Set(lines).size) return; // Duplicate lines
    result["text-decoration-line"] = lines.join(" ");
  }

  return sortProperties(result);
}


=== File: src/text-emphasis.ts ===
// b_path:: src/text-emphasis.ts
import { sortProperties } from "./index";
import isColor from "./is-color";
import normalizeColor from "./normalize-color";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const FILL = /^(filled|open)$/i;
const SHAPE = /^(dot|circle|double-circle|triangle|sesame)$/i;
const STRING_VALUE = /^["'].*["']$/;

export default function textEmphasis(value: string): Record<string, string> | undefined {
  const values = normalizeColor(value).split(/\s+/);

  if (values.length === 1 && KEYWORD.test(values[0])) {
    return sortProperties({
      "text-emphasis-style": values[0],
      "text-emphasis-color": values[0],
    });
  }

  const parsed: { style?: string; color?: string } = {};
  for (let i = 0; i < values.length; i++) {
    const v = values[i];

    if (v === "none") {
      if (parsed.style) return;
      parsed.style = v;
    } else if (STRING_VALUE.test(v)) {
      if (parsed.style) return;
      parsed.style = v;
    } else if (FILL.test(v)) {
      if (parsed.style) return;
      if (i + 1 < values.length && SHAPE.test(values[i + 1])) {
        parsed.style = `${v} ${values[i + 1]}`;
        i++;
      } else {
        parsed.style = v;
      }
    } else if (SHAPE.test(v)) {
      if (parsed.style) return;
      if (i + 1 < values.length && FILL.test(values[i + 1])) {
        parsed.style = `${values[i + 1]} ${v}`;
        i++;
      } else {
        parsed.style = v;
      }
    } else if (isColor(v)) {
      if (parsed.color) return;
      parsed.color = v;
    } else {
      return;
    }
  }

  // Use defaults for missing properties
  // Per CSS spec, the default values for text-emphasis shorthand are:
  //   style: 'none', color: 'currentcolor'
  // See: https://www.w3.org/TR/css-text-decor-3/#propdef-text-emphasis
  return sortProperties({
    "text-emphasis-style": parsed.style || "none",
    "text-emphasis-color": parsed.color || "currentcolor",
  });
}


=== File: src/transition-layers.ts ===
// b_path:: src/transition-layers.ts

import * as csstree from "css-tree";
import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import { hasTopLevelCommas, parseLayersGeneric } from "./layer-parser-utils";
import type { TransitionLayer, TransitionResult } from "./schema";

// CSS default values for transition properties
export const TRANSITION_DEFAULTS = {
  property: "all",
  duration: "0s",
  timingFunction: "ease",
  delay: "0s",
} as const;

/**
 * Detects if a transition value needs advanced parsing (multi-layer transitions or complex functions)
 */
export function needsAdvancedParser(value: string): boolean {
  return hasTopLevelCommas(value, true);
}

/**
 * Parses a complex transition value using css-tree AST parsing
 */
export function parseTransitionLayers(value: string): TransitionResult | undefined {
  const layers = parseLayersGeneric(value, parseSingleLayer);
  return layers ? { layers } : undefined;
}

/**
 * Parses a single transition layer using css-tree AST parsing
 */
function parseSingleLayer(layerValue: string): TransitionLayer | undefined {
  const result: TransitionLayer = {};

  const ast = csstree.parse(layerValue.trim(), { context: "value" });

  // Collect all child nodes from the Value node
  const children: csstree.CssNode[] = [];
  csstree.walk(ast, {
    visit: "Value",
    enter: (node: csstree.Value) => {
      if (node.children) {
        node.children.forEach((child) => {
          children.push(child);
        });
      }
    },
  });

  // Process children in order, handling transition property parsing
  if (!processCssChildren(children, result)) {
    return undefined; // Parsing failed due to invalid syntax
  }

  return result;
}

/**
 * Processes CSS AST children sequentially to extract transition properties
 *
 * This function handles the parsing of CSS transition layer syntax,
 * including property names, time values, and timing functions.
 * CSS ordering rules: first time = duration, second time = delay
 *
 * Returns false if parsing should fail (e.g., too many time values)
 */
function processCssChildren(children: csstree.CssNode[], result: TransitionLayer): boolean {
  let timeCount = 0; // Track first vs second time value

  for (const child of children) {
    // Skip whitespace and operators
    if (child.type === "WhiteSpace" || child.type === "Operator") {
      continue;
    }

    // Handle time values first (duration and delay)
    if (child.type === "Dimension") {
      const timeValue = csstree.generate(child);
      if (isTime(timeValue)) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = timeValue;
        } else {
          result.delay = timeValue;
        }
        timeCount++;
        continue;
      }
    }

    // Handle var() functions as time values
    if (child.type === "Function") {
      const funcValue = csstree.generate(child);
      if (funcValue.startsWith("var(")) {
        if (timeCount >= 2) {
          // More than 2 time values is invalid
          return false;
        }
        if (timeCount === 0) {
          result.duration = funcValue;
        } else {
          result.delay = funcValue;
        }
        timeCount++;
        continue;
      }
    }

    // Handle timing functions (keywords and functions)
    if (!result.timingFunction) {
      if (child.type === "Identifier") {
        const timingValue = csstree.generate(child);
        if (isTimingFunction(timingValue)) {
          result.timingFunction = timingValue;
          continue;
        }
      }

      if (child.type === "Function") {
        const funcValue = csstree.generate(child);
        if (isTimingFunction(funcValue)) {
          // Fix spacing in function calls (css-tree removes spaces after commas)
          result.timingFunction = funcValue.replace(/,([^\s])/g, ", $1");
          continue;
        }
      }
    }

    // Handle transition-property (none, all, or CSS property names)
    if (child.type === "Identifier" && !result.property) {
      const name = (child as csstree.Identifier).name;
      if (name === "none" || name === "all") {
        result.property = name;
        continue;
      }
      // Check if it looks like a CSS property name (not a timing function)
      // Allow vendor-prefixed properties starting with hyphen
      if (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(name) && !isTimingFunction(name)) {
        result.property = name;
      }
    }
  }

  return true;
}

/**
 * Reconstructs final CSS properties from layer objects
 */
export function reconstructLayers(layers: TransitionLayer[]): Record<string, string> {
  const result: Record<string, string> = {};

  // Collect all layer values for each property
  const properties = {
    "transition-property": layers.map((l) => l.property || TRANSITION_DEFAULTS.property),
    "transition-duration": layers.map((l) => l.duration || TRANSITION_DEFAULTS.duration),
    "transition-timing-function": layers.map(
      (l) => l.timingFunction || TRANSITION_DEFAULTS.timingFunction
    ),
    "transition-delay": layers.map((l) => l.delay || TRANSITION_DEFAULTS.delay),
  };

  // Join layer values with commas
  Object.entries(properties).forEach(([property, values]) => {
    result[property] = values.join(", ");
  });

  return result;
}


=== File: src/transition.ts ===
// b_path:: src/transition.ts

import isTime from "./is-time";
import isTimingFunction from "./is-timing-function";
import { needsAdvancedParser, parseTransitionLayers, reconstructLayers } from "./transition-layers";

const KEYWORD = /^(inherit|initial|unset|revert)$/i;
const PROPERTY_KEYWORD = /^(none|all)$/i;

export default function transition(value: string): Record<string, string> | undefined {
  // Handle global keywords first
  if (KEYWORD.test(value.trim())) {
    return {
      "transition-property": value.trim(),
      "transition-duration": value.trim(),
      "transition-timing-function": value.trim(),
      "transition-delay": value.trim(),
    };
  }

  // Check for multi-layer syntax
  if (needsAdvancedParser(value)) {
    const layeredResult = parseTransitionLayers(value);
    if (layeredResult) {
      return reconstructLayers(layeredResult.layers);
    }
    return undefined; // Advanced parsing failed
  }

  // Simple single-layer fallback parser
  const result: Record<string, string> = {};
  const tokens = value.trim().split(/\s+/);
  let timeCount = 0; // Track first vs second time value

  for (const token of tokens) {
    // Handle time values first (duration and delay) - CSS allows flexible ordering
    if (isTime(token) || token.startsWith("var(")) {
      if (timeCount === 0) {
        result["transition-duration"] = token;
      } else if (timeCount === 1) {
        result["transition-delay"] = token;
      } else {
        // More than 2 time values is invalid
        return undefined;
      }
      timeCount++;
      continue;
    }

    // Handle timing functions
    if (!result["transition-timing-function"] && isTimingFunction(token)) {
      result["transition-timing-function"] = token;
      continue;
    }

    // Handle transition-property (none, all, or CSS property names)
    // Only if we haven't set it yet, and it's not a timing function
    if (!result["transition-property"]) {
      if (PROPERTY_KEYWORD.test(token)) {
        result["transition-property"] = token;
        continue;
      }
      // Check if it looks like a CSS property name (not a timing function)
      // Allow vendor-prefixed properties starting with hyphen
      if (/^-?[a-zA-Z][a-zA-Z0-9-]*$/.test(token) && !isTimingFunction(token)) {
        result["transition-property"] = token;
        continue;
      }
    }

    // If token doesn't match any category, it's invalid
    return undefined;
  }

  // Accept single-token property values - they will expand to defaults

  // Build final result with defaults
  return {
    "transition-property": result["transition-property"] || "all",
    "transition-duration": result["transition-duration"] || "0s",
    "transition-timing-function": result["transition-timing-function"] || "ease",
    "transition-delay": result["transition-delay"] || "0s",
  };
}


=== File: src/validate.ts ===
// b_path:: src/validate.ts
/**
 * Validates CSS stylesheet syntax and property values, providing detailed error formatting.
 *
 * This function parses CSS using the css-tree library and validates each CSS property
 * against the CSS specification. When validation errors are found, it generates
 * formatted error messages with visual context including line numbers, code snippets,
 * and precise error location indicators.
 *
 * @param css - The CSS string to validate
 *
 * @returns StylesheetValidation object containing:
 *   - ok: boolean indicating if validation passed (no errors)
 *   - errors: Array of syntax parsing errors (malformed CSS)
 *   - warnings: Array of property validation errors (invalid property values)
 *
 * @remarks
 * - Context window shows ±2 lines around each error for better debugging
 * - Long lines are intelligently truncated with ellipses (…) for readability
 * - Pointer indicators (^^^) precisely mark the error location and length
 * - Duplicate declarations are automatically deduplicated to avoid redundant warnings
 *
 * @throws Does not throw - parsing errors are captured in the returned errors array
 *
 * @since 1.0.0
 */

import * as csstree from "css-tree";
import {
  type BStyleWarning,
  type StylesheetValidation,
  StylesheetValidationSchema,
} from "./schema";

// Constants
const DEFAULT_MAX_LINE_WIDTH = 80;
const LINE_NUMBER_PADDING = 4;
const DEFAULT_CONTEXT_WINDOW_SIZE = 2; // Lines before and after error

export interface BStyleMatchError extends csstree.SyntaxMatchError {
  property: string;
  formattedError?: string;
}

export type { BStyleWarning, StylesheetValidation };

export interface Declaration {
  property: string;
  value: csstree.Value | csstree.Raw;
  node: csstree.CssNode;
}

export interface ErrorFormatOptions {
  maxLineWidth: number;
  contextWindowSize?: number;
}

interface TruncationBounds {
  startPos: number;
  endPos: number;
  needsStartEllipsis: boolean;
  needsEndEllipsis: boolean;
  availableWidth: number;
}

interface FormattedLine {
  content: string;
  adjustedColumn: number;
}

/**
 * Validates a CSS stylesheet for syntax and property value errors.
 *
 * @param css - The CSS string to validate
 * @returns StylesheetValidation object containing validation results
 */
export function validate(css: string): StylesheetValidation {
  const errors: csstree.SyntaxParseError[] = [];
  const warnings: BStyleMatchError[] = [];
  const declarations: Declaration[] = [];
  const syntax = csstree.lexer;
  const uniqueDecls = new Map<string, number>();

  // Parse CSS
  const ast = csstree.parse(css, {
    context: "declarationList",
    positions: true,
    parseAtrulePrelude: true,
    parseRulePrelude: true,
    parseCustomProperty: true,
    onParseError(err: csstree.SyntaxParseError) {
      // biome-ignore lint/correctness/noUnusedVariables: remove stack from err
      const { stack, ...rest } = err;
      errors.push(rest);
    },
  });

  // Extract declarations
  csstree.walk(ast, (node) => {
    if (node.type !== "Declaration") {
      return;
    }
    const id = csstree.generate(node);
    if (uniqueDecls.has(id)) {
      uniqueDecls.set(id, uniqueDecls.get(id)! + 1);
      return;
    }
    uniqueDecls.set(id, 1);
    declarations.push({ property: node.property, value: node.value, node });
  });

  // Validate declarations
  // Suppress noisy csstree-match iteration warnings during matching.
  // Control via env var: BStyle_CSSTREE_LOG_LEVEL=ERROR (default) suppresses these messages.
  const suppressNoise = (msg: unknown): boolean => {
    try {
      const s = String(msg);
      return /\[csstree-match\]\s*BREAK after/i.test(s);
    } catch {
      return false;
    }
  };
  const LOG_LEVEL = (process.env.BStyle_CSSTREE_LOG_LEVEL || "ERROR").toUpperCase();
  const QUIET = LOG_LEVEL === "ERROR" || LOG_LEVEL === "SILENT";
  const origWarn = console.warn;
  const origError = console.error;
  try {
    if (QUIET) {
      console.warn = (...args: Parameters<typeof console.warn>) => {
        if (args.length && suppressNoise(args[0])) return;
        return origWarn(...args);
      };
      console.error = (...args: Parameters<typeof console.error>) => {
        if (args.length && suppressNoise(args[0])) return;
        return origError(...args);
      };
    }

    for (const decl of declarations) {
      const match = syntax.matchProperty(decl.property, decl.value);
      const error = match.error as csstree.SyntaxMatchError;

      if (!error) continue;

      // biome-ignore lint/correctness/noUnusedVariables: remove stack from error
      const { stack, name, ...rest } = error;
      warnings.push({
        property: decl.property,
        name,
        ...rest,
      });
    }
  } finally {
    // Always restore console methods
    console.warn = origWarn;
    console.error = origError;
  }

  // Format and display warnings
  const formattedWarnings: BStyleWarning[] = [];

  if (warnings.length > 0) {
    const cssLines = css.split("\n");
    for (const warning of warnings) {
      const formattedError = formatErrorDisplay(cssLines, warning);
      formattedWarnings.push({
        property: warning.property,
        name: warning.name,
        syntax: warning.syntax,
        formattedWarning: `Errors found in: ${warning.property}\n${formattedError.join("\n")}`,
      });
    }
  }

  // Validate and return using Zod schema for type safety
  const result = {
    ok: errors.length === 0,
    errors,
    warnings: formattedWarnings,
  };

  // Validate the result against our Zod schema for runtime type safety
  return StylesheetValidationSchema.parse(result);
}

export function validateDeclaration(value: string, prop: string): StylesheetValidation {
  const css = `.class {${prop}: ${value};}`;
  const result = validate(css);
  return result;
}

// Helper functions
/**
 * Calculates the line window to display around an error line.
 * Shows contextWindowSize lines before and after the error for better context.
 *
 * @param errorLine - The line number where the error occurred
 * @param totalLines - Total number of lines in the CSS
 * @param contextWindowSize - Number of lines to show before and after error (default: 2)
 * @returns Object with start and end line numbers for the context window
 */
function calculateLineWindow(
  errorLine: number,
  totalLines: number,
  contextWindowSize: number = DEFAULT_CONTEXT_WINDOW_SIZE
): { start: number; end: number } {
  const start = Math.max(1, errorLine - contextWindowSize);
  const end = Math.min(totalLines, errorLine + contextWindowSize);
  return { start, end };
}

function formatLineNumber(lineNum: number, maxLineNum: number): string {
  const maxDigits = Math.max(maxLineNum.toString().length, 1);
  const paddedNum = lineNum.toString().padStart(maxDigits, " ");
  const prefix = " ".repeat(LINE_NUMBER_PADDING - maxDigits);
  return `${prefix}${paddedNum} |`;
}

function trimLine(line: string): { trimmed: string; spacesRemoved: number } {
  const trimmed = line.trimStart();
  const spacesRemoved = line.length - trimmed.length;
  return { trimmed, spacesRemoved };
}

function calculateTruncationBounds(
  lineLength: number,
  errorColumn: number,
  maxWidth: number
): TruncationBounds {
  if (lineLength <= maxWidth) {
    return {
      startPos: 0,
      endPos: lineLength,
      needsStartEllipsis: false,
      needsEndEllipsis: false,
      availableWidth: maxWidth,
    };
  }

  // Reserve space for potential ellipses
  let availableWidth = maxWidth - 2;
  const halfWidth = Math.floor(availableWidth / 2);
  let startPos = Math.max(0, errorColumn - halfWidth - 1);

  // Determine if we need start ellipsis
  const needsStartEllipsis = startPos > 0;

  if (!needsStartEllipsis) {
    // No start truncation - reclaim space for end-only ellipsis
    availableWidth = maxWidth - 1;
  } else {
    // Skip one additional character for better spacing after ellipsis
    startPos = startPos + 1;
  }

  let endPos = startPos + availableWidth;
  let needsEndEllipsis = endPos < lineLength;

  // Adjust if we hit the end of the line
  if (endPos >= lineLength) {
    endPos = lineLength;
    needsEndEllipsis = false;

    if (needsStartEllipsis) {
      startPos = Math.max(0, endPos - availableWidth);
    }
  }

  return {
    startPos,
    endPos,
    needsStartEllipsis,
    needsEndEllipsis,
    availableWidth,
  };
}

function applyTruncation(
  line: string,
  bounds: TruncationBounds,
  originalErrorColumn: number
): FormattedLine {
  let content = line.slice(bounds.startPos, bounds.endPos);
  let adjustedColumn = originalErrorColumn - bounds.startPos;

  if (bounds.needsStartEllipsis) {
    content = `…${content}`;
    adjustedColumn = adjustedColumn + 1;
  }

  if (bounds.needsEndEllipsis) {
    content = `${content}…`;
  }

  return { content, adjustedColumn };
}

function formatContextLine(line: string, maxWidth: number): string {
  const { trimmed } = trimLine(line);

  if (trimmed.length <= maxWidth) {
    return trimmed;
  }

  return `${trimmed.slice(0, maxWidth - 1)}…`;
}

function formatErrorLine(line: string, errorColumn: number, maxWidth: number): FormattedLine {
  // Input validation
  if (errorColumn < 1) {
    throw new Error("Error column must be >= 1");
  }

  const { trimmed, spacesRemoved } = trimLine(line);
  const adjustedErrorColumn = Math.max(1, errorColumn - spacesRemoved);

  // Handle case where line fits without truncation after trimming
  if (trimmed.length <= maxWidth) {
    return {
      content: trimmed,
      adjustedColumn: adjustedErrorColumn,
    };
  }

  // Calculate truncation bounds using the original error column position
  const bounds = calculateTruncationBounds(line.length, errorColumn, maxWidth);

  // Special handling for start-of-line case (after trimming consideration)
  if (bounds.startPos === 0 || bounds.startPos <= spacesRemoved) {
    // Use trimmed line for start-of-line truncation
    const trimmedBounds = calculateTruncationBounds(trimmed.length, adjustedErrorColumn, maxWidth);
    return applyTruncation(trimmed, trimmedBounds, adjustedErrorColumn);
  }

  // Standard middle-of-line truncation
  return applyTruncation(line, bounds, errorColumn);
}

function createPointerLine(prefixLength: number, column: number, length: number): string {
  const safeLength = Math.max(1, length ?? 1);
  const safeColumn = Math.max(1, column);

  const pointerPrefix = " ".repeat(prefixLength);
  const dashes = "-".repeat(safeColumn - 1);
  const carets = "^".repeat(safeLength);

  return pointerPrefix + dashes + carets;
}

/**
 * Formats and displays CSS validation errors with visual context.
 * Shows the error line with surrounding context, line numbers, and pointer indicators.
 *
 * @param cssLines - Array of CSS source lines
 * @param warning - The validation error/warning to format
 * @param options - Formatting options (maxLineWidth, contextWindowSize)
 * @returns Array of formatted strings representing the error display
 *
 * @example
 * // Error at line 5, column 10:
 * //   3 | .class {
 * //   4 |   margin: 10px;
 * //   5 |   color: notacolor;
 * //       ---------^^^^^^^^^^^
 * //   6 | }
 */
function formatErrorDisplay(
  cssLines: string[],
  warning: BStyleMatchError,
  options: ErrorFormatOptions = {
    maxLineWidth: DEFAULT_MAX_LINE_WIDTH,
    contextWindowSize: DEFAULT_CONTEXT_WINDOW_SIZE,
  }
): string[] {
  // Input validation
  if (!cssLines.length || warning.line < 1 || warning.line > cssLines.length) {
    return [`Invalid error location: line ${warning.line}`];
  }
  const errorLine = warning.line;
  const errorColumn = warning.column;
  const mismatchLength = warning.mismatchLength ?? 1;
  const contextWindowSize = options.contextWindowSize ?? DEFAULT_CONTEXT_WINDOW_SIZE;

  const { start, end } = calculateLineWindow(errorLine, cssLines.length, contextWindowSize);
  const maxLineNum = end;
  const linePrefix = formatLineNumber(1, maxLineNum);
  const prefixLength = linePrefix.length;
  const availableWidth = options.maxLineWidth - prefixLength;

  const result: string[] = [];

  for (let lineNum = start; lineNum <= end; lineNum++) {
    const lineIndex = lineNum - 1;
    const currentLine = cssLines[lineIndex] ?? "";
    const currentPrefix = formatLineNumber(lineNum, maxLineNum);

    if (lineNum === errorLine) {
      // Format error line
      const { content, adjustedColumn } = formatErrorLine(currentLine, errorColumn, availableWidth);

      result.push(currentPrefix + content);

      // Add pointer line
      const pointerLine = createPointerLine(prefixLength, adjustedColumn, mismatchLength);
      result.push(pointerLine);
    } else {
      // Format context line
      const formattedLine = formatContextLine(currentLine, availableWidth);
      result.push(currentPrefix + formattedLine);
    }
  }

  return result;
}


