# Background Parse — Longhand Fusion (Design & Action Plan)

Owner: **b\_style**
Last updated: **Aug 31, 2025**
Scope: Make `background/parse.ts` fuse **shorthand** + **longhands** in source order into a single, aligned `BackgroundIR` per rule (base/::before/::after).

---

## 1) Goal

Provide a robust parser that, for each rule block, reads **all** background-related declarations (in source order) and produces a single `BackgroundIR` where:

* Layer count is taken from the **last** `background-image` (or the shorthand that sets images) in source order.
* All layered longhands are **aligned** to that layer count (broadcast/pad/truncate).
* `background-color` becomes the stack color.
* `background-blend-mode` is handled as a layered list aligned to the final layer count (even though it isn’t part of the `background` shorthand).

We keep all existing contracts (bake happens at **serialize**, not during parse).

---

## 2) Background properties (what we fuse)

**Layered lists (align to image arity):**

* `background-image`
* `background-position`
* `background-size`
* `background-repeat`
* `background-origin`
* `background-clip`
* `background-attachment`
* `background-blend-mode` *(not in shorthand; separate)*

**Stack-level:**

* `background-color`

**Shorthand:**

* `background` — sets/clears *all background-* lists and color **except** `background-blend-mode`.

**Initial values (per layer) used for padding:**

* position: `0% 0%`
* size: `auto auto`
* repeat: `repeat`
* origin: `padding-box`
* clip: `border-box`
* attachment: `scroll`
* blend-mode: `normal`

---

## 3) Fusion rules (source-order semantics)

1. **Shorthand** resets the entire background layer set to what it specifies and clears other layered lists to their **initials** for the new layer count (since unspecified longhands are reset by the shorthand). `background-blend-mode` is **not** reset by this (per spec) and must be preserved until explicitly overridden.
2. **`background-image`** sets the final **layer count**. When it changes, **realign** every other layered list to the new count:

   * length = 0 → fill with initial
   * length = 1 → broadcast to all layers
   * 1 < length < count → copy then pad with initial
   * length > count → truncate
3. **Other layered longhands** (`position`, `size`, `repeat`, `origin`, `clip`, `attachment`): align to the **current** layer count per the same rules.
4. **`background-blend-mode`**: align to the **current** layer count; missing entries are `normal`.
5. **`background-color`**: stack-level; last assignment wins.
6. **`background-image: none`** → layer count becomes 0. Layered lists collapse to empty; `background-color` (if any) remains.

---

## 4) Data flow & builder

We add a small internal **builder** that accumulates state while scanning declarations in source order.

```ts
// background/parse.ts
interface BgBuilder {
  images: string[];
  positions: string[];
  sizes: string[];
  repeats: string[];
  origins: string[];
  clips: string[];
  attachments: string[];
  blends: string[];
  color?: string;
  layerCount: number;
}
```

**Helpers** (place in `background/utils.ts`):

* `alignToCount(values: readonly string[], count: number, initial: string): string[]`
* `initials` map of per-property defaults.
* `splitCommaList(value: string): string[]` *(use existing core splitter if available)*
* `parseShorthand(background: string): BackgroundIR` *(already have `importBackground`)*

**Algorithm:**

1. `initBuilder()` → empty arrays, `layerCount = 0`, `blends = []`.
2. Iterate block declarations in **source order**.

   * `background`: parse → get images, per-layer lists, color. Set all arrays to the shorthand values; set `layerCount`. Reset other layered lists to **initials** where shorthand didn’t specify. **Do not** touch `blends`.
   * `background-image`: set `images`, update `layerCount`, then `alignToCount(...)` all other layered arrays using initials.
   * Other layered longhands: parse their comma lists, then `alignToCount(values, layerCount, initial)` and assign.
   * `background-blend-mode`: same alignment as above (initial = `normal`).
   * `background-color`: assign `color`.
3. `fuseToIR(builder)`: zip arrays 0..`layerCount-1` into `BackgroundLayer[]`, dropping entries that equal **initial** (optional micro-optimization). Set `ir.color = builder.color`.

---

## 5) API surface (new/updated)

**File:** `src/lib/css/background/parse.ts`

```ts
export interface CSSDecl { prop: string; value: string }

/** Unified import that fuses shorthand + longhands. */
export function importBackgroundFromDecls(
  decls: readonly CSSDecl[]
): { ir: BackgroundIR | null; warnings: string[] };

/** (Existing) Shorthand-only import remains for targeted use cases. */
export function importBackground(shorthand: string): { ir: BackgroundIR | null; errors?: string[] };
```

**Where it’s used:**

* `src/lib/bstyle/parse.ts`: replace the "lastBackground/lastBgColor/lastBlend" ad-hoc logic with:

  1. collect **all** background-related declarations from the rule block in order;
  2. call `importBackgroundFromDecls(decls)`;
  3. assign `base.bg` or `pseudos.*.bg` from returned `ir` when non-null.

---

## 6) Edge cases & behavior

* **Color-only rule:** if no images are set but `background-color` is present → `ir.layers = []`, `ir.color` set.
* **Lists > 0 with `layerCount = 0`:** ignore layered longhands (no images). Add a note in `warnings` (non-fatal).
* **Broadcast/truncate diagnostics:** optionally add warnings when broadcasting a single value across N layers or truncating a list.
* **Shorthand resets:** on encountering a shorthand, clear all layered lists to what the shorthand explicitly sets (and initials for the rest). `background-blend-mode` remains as-is until a later `background-blend-mode` is seen.

---

## 7) Worked examples

### A) Mixed order, broadcast + blend

```css
.sel {
  background: red, url(a.png);
  background-position: 0 0, 50% 50%;
  background-size: cover;                 /* broadcasts to both */
  background-image: url(b.png), url(c.png); /* changes images → realign */
  background-blend-mode: screen;          /* broadcasts to both */
}
```

**Result:**

* images: `[url(b.png), url(c.png)]`
* positions: `[0 0, 50% 50%]`
* sizes: `[cover, cover]`
* repeats/origins/clips/attachments: padded with initials
* blends: `[screen, screen]`
* color: `red` (stack)

### B) Color-only

```css
.sel { background-color: #112233; }
```

→ `layers: []`, `color: #112233`

### C) `none`

```css
.sel {
  background: url(a.png), url(b.png);
  background-image: none; /* wipes layers */
  background-color: #f00;
}
```

→ `layers: []`, `color: #f00`

---

## 8) Implementation plan (files & steps)

**A) `background/utils.ts`**

* [ ] Add `INITIALS` constants:

  ```ts
  export const INITIALS = {
    position: "0% 0%",
    size: "auto auto",
    repeat: "repeat",
    origin: "padding-box",
    clip: "border-box",
    attachment: "scroll",
    blend: "normal",
  } as const;
  ```
* [ ] Add `alignToCount(values, count, initial)`.
* [ ] Add `splitCommaList(value)` using existing core splitter or a simple top-level comma splitter.

**B) `background/parse.ts`**

* [ ] Define `BgBuilder`, `initBuilder()`.
* [ ] Implement `applyShorthand(builder, shorthand)` using existing `importBackground` to parse the shorthand, then copy arrays into builder and fill unspecified lists with initials.
* [ ] Implement `applyLayeredLonghand(builder, prop, value)` with alignment.
* [ ] Implement `importBackgroundFromDecls(decls)` (iterate in order, call the helpers, return `{ ir, warnings }`).
* [ ] Export from `background/index.ts`.

**C) `bstyle/parse.ts`**

* [ ] In each rule, collect declarations:

  ```ts
  const decls: CSSDecl[] = [];
  node.block.children.forEach(d => {
    if (d.type !== 'Declaration') return;
    const prop = d.property.toLowerCase();
    if (!prop.startsWith('background')) return; // keep only relevant
    decls.push({ prop, value: csstree.generate(d.value).trim() });
  });
  ```
* [ ] Call `importBackgroundFromDecls(decls)` instead of the current lastBackground/lastBgColor/lastBlend handling.
* [ ] Map returned `ir` into `base.bg` or `pseudos.*.bg`.

**D) Tests**

* [ ] Unit tests for `alignToCount` with pad/broadcast/truncate.
* [ ] Fusion tests:

  * shorthand → longhands override order
  * longhands first → later `background-image` re-arity + alignment
  * `none` wipes lists
  * `background-blend-mode` unaffected by shorthand but aligns to layer count
  * color-only

---

## 9) Definition of Done (for fusion)

* Parser accepts any order of `background` + `background-*` and produces a stable, aligned `BackgroundIR`.
* Shorthand resets are honored; blend-mode treated independently.
* Broadcasting, padding, truncation are handled and (optionally) surfaced as warnings.
* E2E shows round-trip: CSS → IR → serialize → expected CSS (formatting differences OK).
* Zero `any`; types inferred from Zod; no `@ts-ignore`.

---

## 10) Nice-to-haves (later)

* Preserve per-layer **initial omissions** (don’t re-emit initials redundantly when serializing longhands).
* Optional strict mode that errors on list length > layer count instead of truncating.
* Media/query awareness (variants) — future milestone.
