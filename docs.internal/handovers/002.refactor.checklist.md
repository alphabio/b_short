Unify “layered broadcasting” warnings
Today each fuse path pushes its own “provided N for M layer(s); truncated” strings. Extract a tiny helper in core/utils:

broadcastList(values, targetCount, initial, label, warnings)
Reuse in both background & mask fuse to keep messages uniform.

Centralize “join layers” & string styles
Add core/shorthand.ts with:

joinLayers(strs: readonly string[]) => strs.join(", ")

(Optionally) normalizeUrlQuotes(s: string) if we ever want deterministic quoting.
Then use it in both background and mask composers so spacing/formatting is 100% consistent.

Round-trip sanity tests (matrix)
Add a small shared test matrix that feeds layered combos through:

decls → fuse → IR → serialize for both background and mask,

checks stability (idempotent where safe) and validates broadcasting/truncation behaviors.

Option bag for per-channel preferences
Let callers choose shorthand strategy per channel (we already do internally, but expose it clearly):

serializeChannels(ch, { background: { prefer }, mask: { prefer } }).

Lightweight value guards (shared)
Background & mask both classify tokens like repeat / origin / clip. Move the keyword guards into core/value-guards.ts so the regexes and accepted sets are shared.

Dead-code & naming sweep

Remove any leftover local splitters or unused helpers.

Ensure all “initial” constants sit beside their channel utils (INITIALS, MASK_INITIALS) and are exported in a consistent pattern.

(Optional) Structured diagnostics
If you want richer UI: change pseudo warnings from string[] → { code, message, details? }[]. The collector keeps working, and consumers can group/summarize.

quick checklist (actionable)

 Add broadcastList helper in core/utils and refactor background/*/fuse + mask/fuse to use it.

 Add joinLayers in core/shorthand.ts; switch both composers to it.

 Extract token keyword regexes to core/value-guards.ts; import in mask/parse (and background if/when we parse shorthand there).

 Add a tests/layered-matrix.spec.ts covering parity cases across bg+mask.

 Expose per-channel prefer options through serializeChannels signature.

 Decide on URL quoting policy (keep “tolerant tests” as is, or normalize during serialize).
